// ---- type definitions ----
.type Var <: symbol
.type Type <: symbol
.type Field <: symbol
.type Index <: Var
.type Invocation <: symbol
.type Method <: symbol
.type Value <: symbol
.type Context = [invo1:Invocation, invo2:Invocation]
.type HContext = [invo:Invocation]

#define ValueIdMacro(id, type) \
    cat(cat(cat(id, "::: "), type), "::: ")

// ---- inputs ----
// inner-procedural facts
.decl AssignVar(to:Var, from:Var)
.decl AssignGlobal(to:Var, from:Var)
.decl AssignStrConstant(to:Var, constant:symbol)
.decl AssignBoolConstant(to:Var, constant:symbol)
.decl AssignIntConstant(to:Var, constant:symbol)
.decl AssignFloatConstant(to:Var, constant:symbol)
.decl AssignBinOp(to:Var, left:Var, op:symbol, right:Var)
.decl LoadField(to:Var, base:Var, f:Field)
.decl StoreField(base:Var, f:Field, from:Var)
.decl LoadIndex(to:Var, base:Var, i:Index)
.decl StoreIndex(base:Var, i:Index, from:Var)
.decl LoadSlice(to:Var, base:Var, st:Var, ed:Var, step:Var)
.decl StoreSlice(base:Var, st:Var, ed:Var, step:Var, from:Var)
.decl StoreFieldSSA(new_base:Var, base:Var, f:Field, from:Var)
.decl StoreIndexSSA(new_base:Var, base:Var, i:Index, from:Var)
.decl StoreSliceSSA(new_base:Var, base:Var, st:Var, ed:Var, step:Var, from:Var)

// inter-procedural facts
.decl Invoke(invo:Invocation, toMeth:Method, inMeth:Method)
.decl ActualParam(index:number, invo:Invocation, var:Var)
.decl FormalParam(index:number, meth:Method, var:Var)
.decl ActualKeyParam(keyword:Var, invo:Invocation, var:Var)
// .decl FormalKeyParam(keyword:Var, meth:Method)
.decl ActualReturn(index:number, invo:Invocation, var:Var)
.decl FormalReturn(index:number, meth:Method, var:Var)

.decl VarInMethod(var:Var, meth:Method)
.decl VarType(var:Var, type:Type)
.decl Alloc(var:Var, value:Value, inMeth:Method)
.decl LocalMethod(meth:Method)
.decl LocalClass(cls:Type)
.decl InvokeInLoop(invo:Invocation)

.input AssignVar
.input AssignGlobal
.input AssignStrConstant
.input AssignBoolConstant
.input AssignIntConstant
.input AssignFloatConstant
.input AssignBinOp
.input LoadField
.input StoreField
.input LoadIndex
.input StoreIndex
.input LoadSlice
.input StoreSlice
.input StoreIndexSSA
.input StoreFieldSSA
.input StoreSliceSSA

.input Invoke
.input ActualParam
.input FormalParam
.input ActualKeyParam
.input ActualReturn
.input FormalReturn
// .input CallGraphEdge
.input VarInMethod
.input VarType
.input Alloc
.input LocalMethod
.input LocalClass
.input InvokeInLoop


/* -------------------
Method specifications
------------------- */
.decl FilteredMethod(meth:Method)
.decl PureMethod(meth:Method)
FilteredMethod(meth) :-
    meth = "__phi__"; meth = "set_field_wrapper";
    meth = "set_index_wrapper"; meth = "set_slice_wrapper".

PureMethod(meth) :-
    meth = "len".

.decl MethodUpdate(index:number, meth:Method)
MethodUpdate(0, "pandas.Series.fillna").
MethodUpdate(0, meth) :-
    Invoke(_, meth, _),
    match(".*[.](fit|fit_transform)", meth).


/* -------------------
Specified cases for data flow analysis 
------------------- */
//  relations
.decl ParamToParamFlow(to:number, from:number, method:Method) 
.decl ParamToRetFlowFilterMethod(to:number, from:number, method:Method)

.decl ParamToRetEquivFlow(to:number, from:number, method:Method)
.decl ParamToRetCondEquivFlow(to:number, from:number, cond_id:number,method:Method)
.decl ParamContentToRetCondEquivFlow(to:number, from:number, cond_id:number,method:Method)
.decl FlowCondition(cond_id:number, keyword:Var, constant:symbol)

// param2param flows
ParamToParamFlow(0, 1, "pandas.Series.fillna").
ParamToRetFlowFilterMethod(0, 0, meth) :-
    Invoke(_, meth, _),
    match(".*[.](fit|fit_transform|transform)", meth).

// equivalent flows
ParamToRetEquivFlow(0, 0, "ndarray.reshape").
ParamToRetEquivFlow(0, 1, "numpy.array").
ParamToRetEquivFlow(0, 1, "sklearn.preprocessing.scale").
ParamToRetEquivFlow(0, 0, meth) :-
    Invoke(_, meth, _),
    match(".*[.](astype)", meth).

ParamToRetEquivFlow(0, 0, meth) :-
    Invoke(_, meth, _),
    match(".*[.](toarray)", meth).

ParamToRetEquivFlow(0, 1, meth) :-
    Invoke(_, meth, _),
    match(".*[.](transform|fit_transform)", meth).

ParamToRetEquivFlow(0, 1, meth) :-
    Invoke(_, meth, _),
    match("pandas[.](Series|DataFrame|get_dummies)", meth).

ParamToRetEquivFlow(0, 0, meth) :-
    Invoke(_, meth, _),
    match("pandas[.](Series|DataFrame)[.](copy|fillna|replace|map|apply|applymap)", meth).

ParamToRetCondEquivFlow(0, 0, 173, meth) :-
    Invoke(_, meth, _),
    match("pandas[.](Series|DataFrame)[.](drop)", meth).

// list member equiv
ParamContentToRetCondEquivFlow(0, 1, 173, meth) :-
    Invoke(_, meth, _),
    match("pandas[.](concat)", meth).

FlowCondition(173, "axis", "1").

// [TODO] specified flows for datasets

/* -------------------
"Taint" inputs (specified locations for reduce/duplicate in pre-processing)
------------------- */
.decl ParamToRetTaintSourceMethod(to:number, from:number, method:Method, taintType:symbol)
.decl ParamToParamTaintSourceMethod(to:number, from:number, method:Method, taintType:symbol)
.decl RetTaintSourceMethod(retIndex:number, method:Method, taintType:symbol)
.decl ParamToRetCondTaintSourceMethod(to:number, from:number, cond_id:number, method:Method, taintType:symbol)
.decl ParamToParamCondTaintSourceMethod(to:number, from:number, cond_id:number, method:Method, taintType:symbol)
.decl TaintCondition(cond_id:number, src_idx:number, taintType:symbol)


ParamToRetTaintSourceMethod(0, 1, meth, "rowset") :-
    Invoke(_, meth, _),
    match("numpy[.](nan)?(average|median|mean|std|var)", meth).
// ParamToRetTaintSourceMethod(0, 0, "Unknown.mean", "rowset").
ParamToRetTaintSourceMethod(0, 1, "pandas.cut", "rowset").
ParamToRetTaintSourceMethod(0, 1, "pandas.qcut", "rowset").
ParamToRetTaintSourceMethod(0, 0, meth, "rowset") :-
    Invoke(_, meth, _),
    match(".*(Unknown|Series|DataFrame|FrameOrSeries)[.](groupby|corr|cov|mode|mean|median|std|sum|describe)", meth). // some of them actually depends on the axis
ParamToRetTaintSourceMethod(0, 0, ".*[.]DataFrame.groupby", "rowset").
ParamToRetTaintSourceMethod(0, 1, "sklearn.preprocessing.scale", "rowset"). 
// sklearn.preprocessing.normalize when axis = 1

// pre-processing leaks 
ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset") :-
    Invoke(_, meth, _),
    match("(KBinsDiscretizer|PowerTransformer|QuantileTransformer|MaxAbsScaler|StandardScaler|MinMaxScaler|RobustScaler)[.]fit_transform", meth). 

ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset")  :-
    Invoke(_, meth, _),
    match("(KBinsDiscretizer|PowerTransformer|QuantileTransformer|MaxAbsScaler|StandardScaler|MinMaxScaler|RobustScaler)[.]fit", meth).

// imputer leaks (depends on the strategy)
ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset") :-
    Invoke(_, meth, _),
    match("(Imputer|SimpleImputer|IterativeImputer|KNNImputer)[.]fit_transform", meth). 

ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset")  :-
    Invoke(_, meth, _),
    match("(Imputer|SimpleImputer|IterativeImputer|KNNImputer)[.]fit", meth).

// feature selection leaks
ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset") :-
    Invoke(_, meth, _),
    match("(GenericUnivariateSelect|SelectPercentile|SelectKBest|SelectFpr|SelectFdr|SelectFromModel|SelectFwe|SequentialFeatureSelector|RFE|RFECV|VarianceThreshold)[.]fit_transform", meth). 

ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset")  :-
    Invoke(_, meth, _),
    match("(GenericUnivariateSelect|SelectPercentile|SelectKBest|SelectFpr|SelectFdr|SelectFromModel|SelectFwe|SequentialFeatureSelector|RFE|RFECV|VarianceThreshold)[.]fit", meth). 

// other leaks
ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset") :-
    Invoke(_, meth, _),
    match("(CountVectorizer|HashingVectorizer|TfidfTransformer|TfidfVectorizer|PCA)[.]fit_transform", meth). 

ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset")  :-
    Invoke(_, meth, _),
    match("(CountVectorizer|HashingVectorizer|TfidfTransformer|TfidfVectorizer|PCA)[.]fit", meth).

// pipeline leaks
RetTaintSourceMethod(0, "sklearn.preprocessing.Imputer", "pipeline"). // not always a problem, be conservative
RetTaintSourceMethod(0, "sklearn.preprocessing.MinMaxScaler", "pipeline"). 

ParamToRetCondTaintSourceMethod(0, 1, 4027, "DataFrameMapper.fit_transform", "rowset"). 
ParamToRetCondTaintSourceMethod(0, 1, 4027, "Pipeline.fit_transform",  "rowset").
TaintCondition(4027, 0, "pipeline").

ParamToRetTaintSourceMethod(0, 1, "ImageDataGenerator.flow", "dup"). 

// oversampling leak
ParamToRetTaintSourceMethod(0, 1, meth, "dup")  :-
    Invoke(_, meth, _),
    match("(RandomOverSampler|SMOTE|SMOTENC|SMOTEN|ADASYN|BorderlineSMOTE|KMeansSMOTE|SVMSMOTE|SMOTEENN|SMOTETomek)[.]fit_resample", meth).

/* -------------------
Locations for train/val/test data
------------------- */
.decl TrainingData(method:Method, model_idx:number, data_index:number)
.decl TrainingDataByKey(method:Method, model_idx:number, datakw:Var)
.decl TestData(method:Method, model_idx:number, data_index:number)
.decl TestDataByKey(method:Method, model_idx:number, datakw:Var)
.decl ValData(method:Method, model_idx:number, data_index:number)
.decl ValDataByKey(method:Method, model_idx:number, datakw:Var)
.decl ScoredData(method:Method, model_idx:number, data_index:number)
.decl ScoredResult(method:Method, result_index:number)
.decl FilteredTrainingMethod(method:Method)

TrainingData(meth, 0, 1) :-
    Invoke(_, meth, _),
    match(".*[.](fit|fit_generator)", meth).
TrainingDataByKey(meth, 0, "generator") :-
    Invoke(_, meth, _),
    match(".*[.](fit_generator)", meth).


TestData(meth, 0, 1) :-
    Invoke(_, meth, _),
    match(".*[.](predict|score|evaluate|predict_proba)", meth).
TestDataByKey(meth, 0, "x") :-
    Invoke(_, meth, _),
    match(".*[.](predict_proba)", meth).


ValData(meth, 0, 1) :-
    Invoke(_, meth, _),
    match(".*(GridSearchCV|HalvingGridSearchCV|ParameterGrid|ParameterSampler|RandomizedSearchCV|HalvingRandomSearchCV)[.]fit", meth).
ValDataByKey(meth, 0, "validation_data") :-
    Invoke(_, meth, _),
    match(".*[.](fit|fit_generator)", meth).


ScoredData(meth, 0, 1) :-
    Invoke(_, meth, _),
    match(".*[.](score|evaluate)", meth).
ScoredResult(meth, 2) :-
    Invoke(_, meth, _),
    match(".*(accuracy_score|balanced_accuracy_score|top_k_accuracy_score|average_precision_score|brier_score_loss|f1_score|f1_score|f1_score|f1_score|f1_score|log_loss|precision_score|recall_score|jaccard_score|roc_auc_score|roc_auc_score|roc_auc_score|roc_auc_score|roc_auc_score|adjusted_mutual_info_score|adjusted_rand_score|completeness_score|fowlkes_mallows_score|homogeneity_score|mutual_info_score|normalized_mutual_info_score|rand_score|v_measure_score|explained_variance_score|max_error|mean_absolute_error|mean_squared_error|mean_squared_error|mean_squared_log_error|median_absolute_error|r2_score|mean_poisson_deviance|mean_gamma_deviance|mean_absolute_percentage_errors)", meth).

// known pre-processing methods not for training a model
FilteredTrainingMethod(meth) :-
    Invoke(_, meth, _),
    (match("(GenericUnivariateSelect|SelectPercentile|SelectKBest|SelectFpr|SelectFdr|SelectFromModel|SelectFwe|SequentialFeatureSelector|RFE|RFECV|VarianceThreshold)[.]fit", meth);
    match("(CountVectorizer|HashingVectorizer|TfidfTransformer|TfidfVectorizer|PCA)[.]fit", meth);
    match("(Imputer|SimpleImputer|IterativeImputer|KNNImputer)[.]fit", meth);
    match("(FunctionTransformer|KBinsDiscretizer|KernelCenterer|LabelBinarizer|LabelEncoder|MultiLabelBinarizer|MaxAbsScaler|MinMaxScaler|Normalizer|OneHotEncoder|OrdinalEncoder|PolynomialFeatures|PowerTransformer|QuantileTransformer|RobustScaler|SplineTransformer|StandardScaler)[.]fit", meth)).

// ---- Constant Propagation ----
.decl ConstantValue(var:Var, constant:symbol)
.decl VarEquals(var1:Var, var2:Var)

ConstantValue(var, constant) :-
    AssignBoolConstant(var, constant);
    AssignStrConstant(var, constant);
    AssignIntConstant(var, constant);
    AssignFloatConstant(var, constant).

ConstantValue(to, constant) :-
    VarPointsTo(from, _, value, hCtx),
    VarPointsTo(to, _, value, hCtx),
    ConstantValue(from, constant).

// ---- Common Expression Detection ----
VarEquals(var1, var2) :-
    ConstantValue(var1, constant),
    ConstantValue(var2, constant).

VarEquals(var, var) :-
    VarPointsTo(var, _, _, _).

VarEquals(var1, var2) :-
    (LoadField(var1, base1, fld), LoadField(var2, base2, fld);
    LoadIndex(var1, base1, i1), LoadIndex(var2, base2, i2), (i1 = i2; VarEquals(i1, i2))),
    VarEquals(base1, base2).

VarEquals(var1, var2) :-
    CallGraphEdge(invo1, _, meth, _), ActualParam(1, invo1, param1), ActualReturn(0, invo1, var1),
    CallGraphEdge(invo2, _, meth, _), ActualParam(1, invo2, param2), ActualReturn(0, invo2, var2),
    PureMethod(meth),
    VarEquals(param1, param2).

// ---- call-graph construction ----
.decl CallGraphEdge(invo:Invocation, callerCtx:Context, meth:Method, calleeCtx:Context)
.decl Reachable(meth:Method, ctx:Context)

Reachable(toMeth, calleeCtx),
CallGraphEdge(invo, callerCtx, toMeth, calleeCtx) :-
    Invoke(invo, toMeth, inMeth),
    Reachable(inMeth, callerCtx),
    callerCtx = [invo1, invo2],
    calleeCtx = [invo2, invo].

Reachable("", ["", ""]). // entry point

/* -------------------
    Pointer analysis
------------------- */

.decl VarPointsTo(var:Var, ctx:Context, value:Value, hctx:HContext)
.decl IndexContentPointsTo(baseValue:Value, baseHctx:HContext, value:Value, hctx:HContext) // always insensitive
.decl FieldPointsTo(base:Value, baseHctx:HContext, field:Field, value:Value, hctx:HContext)
.decl InterProcAssign(to:Var, calleeCtx:Context, from:Var, callerCtx:Context)
.decl SliceIndex(st:Var, ed:Var, step:Var, index:Index)

// base case
VarPointsTo(var, ctx, value, hctx) :- 
    Alloc(var, value, inMeth),
    Reachable(inMeth, ctx),
    ctx = [invo1, invo2],
    hctx = [invo2].

// local assignment
VarPointsTo(to, ctx, value, hctx) :- 
    AssignVar(to, from),
    VarPointsTo(from, ctx, value, hctx). 

// assignment from/to global
VarPointsTo(to, meth_ctx, value, hctx) :- 
    AssignGlobal(to, from),
    VarInMethod(to, meth),
    Reachable(meth, meth_ctx),
    VarPointsTo(from, _, value, hctx).

// load/store fields
// the analysis is field-insensitive for unknown fields 
// currently the insensitive part always applies [TODO]
VarPointsTo(to, ctx, value, hctx) :- 
    LoadField(to, base, _),
    VarPointsTo(base, ctx, value, hctx).
VarPointsTo(to, ctx, value, hctx) :- 
    LoadField(to, base, fld),
    VarPointsTo(base, ctx, baseValue, baseHctx),
    FieldPointsTo(baseValue, baseHctx, fld, value, hctx).
FieldPointsTo(baseValue, baseHctx, fld, value, hctx) :-
    StoreField(base, fld, from),
    VarPointsTo(base, ctx, baseValue, baseHctx),
    VarPointsTo(from, ctx, value, hctx).
FieldPointsTo(baseValue, baseHctx, fld, value, hctx) :-
    StoreFieldSSA(_, base, fld, from),
    VarPointsTo(base, ctx, baseValue, baseHctx),
    VarPointsTo(from, ctx, value, hctx).

// load/store indexes
// the base objects could be list/tuple/dict/Series/DataFrame (any type that implements _getitem__ method)
// the semantics depends on specific implementations, e.g., indexing DataFrame may return a copy or a view of the original object
VarPointsTo(to, ctx, value, hctx) :- 
    LoadIndex(to, base, _),
    VarPointsTo(base, ctx, value, hctx). 
VarPointsTo(to, ctx, value, hctx) :- 
    LoadIndex(to, base, _),
    VarPointsTo(base, ctx, baseValue, baseHctx),
    IndexContentPointsTo(baseValue, baseHctx, value, hctx).
// [TODO] add this case
// IndexContentPointsTo(toValue, toHctx, value, hctx) :- 
//     LoadIndex(to, base, _),
//     VarPointsTo(to, ctx, toValue, toHctx),
//     VarPointsTo(base, ctx, baseValue, baseHctx),
//     IndexContentPointsTo(baseValue, baseHctx, value, hctx).
IndexContentPointsTo(baseValue, baseHctx, value, hctx) :- 
    StoreIndex(base, _, from),
    VarPointsTo(base, ctx, baseValue, baseHctx),
    VarPointsTo(from, ctx, value, hctx).
IndexContentPointsTo(baseValue, baseHctx, value, hctx) :- 
    StoreIndexSSA(_, base, _, from),
    VarPointsTo(base, ctx, baseValue, baseHctx),
    VarPointsTo(from, ctx, value, hctx).

// load/store slices
SliceIndex(st, ed, step, index) :-
    LoadSlice(_, _, st, ed, step),
    index = ValueIdMacro(ValueIdMacro(st, ed), step).
SliceIndex(st, ed, step, index) :-
    (StoreSlice(_, st, ed, step, _); StoreSliceSSA(_, _, st, ed, step, _)),
    index = ValueIdMacro(ValueIdMacro(st, ed), step).
// slices are shallow copies; the contents point to the same objects
IndexContentPointsTo(toValue, toHctx, value, hctx) :- 
    LoadSlice(to, from, st, ed, step),
    SliceIndex(st, ed, step, _),
    VarPointsTo(to, ctx, toValue, toHctx),
    VarPointsTo(from, ctx, fromValue, fromHctx),
    IndexContentPointsTo(fromValue, fromHctx, value, hctx).  
IndexContentPointsTo(baseValue, baseHctx, value, hctx) :- 
    StoreSlice(base, st, ed, step, from),
    SliceIndex(st, ed, step, _),
    VarPointsTo(base, ctx, baseValue, baseHctx),
    VarPointsTo(from, ctx, value, hctx).
IndexContentPointsTo(baseValue, baseHctx, value, hctx) :- 
    StoreSliceSSA(_, base, st, ed, step, from),
    SliceIndex(st, ed, step, _),
    VarPointsTo(base, ctx, baseValue, baseHctx),
    VarPointsTo(from, ctx, value, hctx).

// extra cases for SSA
VarPointsTo(new_base, ctx, baseValue, hctx) :- 
    (StoreIndexSSA(new_base, base, _, _); StoreFieldSSA(new_base, base, _, _); StoreSliceSSA(new_base, base, _, _, _, _)),
    VarPointsTo(base, ctx, baseValue, hctx).

// inter-procedural cases
InterProcAssign(to, calleeCtx, from, callerCtx) :-
    CallGraphEdge(invo, callerCtx, meth, calleeCtx),
    !FilteredMethod(meth),
    FormalParam(index, meth, to),
    ActualParam(index, invo, from).
InterProcAssign(to, calleeCtx, from, callerCtx) :-
    CallGraphEdge(invo, callerCtx, meth, calleeCtx),
    !FilteredMethod(meth),
    FormalParam(_, meth, to),
    ActualKeyParam(to, invo, from).
InterProcAssign(to, callerCtx, from, calleeCtx) :-
    CallGraphEdge(invo, callerCtx, meth, calleeCtx),
    !FilteredMethod(meth),
    FormalReturn(index, meth, from),
    ActualReturn(index, invo, to).

VarPointsTo(to, toCtx, value, hctx) :- 
    InterProcAssign(to, toCtx, from, fromCtx),
    VarPointsTo(from, fromCtx, value, hctx).

/* -------------------
    Information flow analysis
------------------- */
.decl FlowFrom(to:Var, toCtx:Context, from:Var, fromCtx:Context, tag:symbol)
.decl FlowFromEdge(to:Var, toCtx:Context, from:Var, fromCtx:Context, tag:symbol)
.decl FlowFromExtended(to:Var, toCtx:Context, from:Var, fromCtx:Context, tag:symbol)
.decl NonDataTransferEdge(to:Var, from:Var)

// unspecified methods: all parameters flow into return results
FlowFromEdge(to, toCtx, from, fromCtx, "normal") :-
    CallGraphEdge(invo, _, meth, _),
    (ActualParam(_, invo, from); ActualKeyParam(_, invo, from)),
    ActualReturn(_, invo, to),
    (!LocalMethod(meth); meth = "__phi__"),
    VarPointsTo(to, toCtx, _, _),
    VarPointsTo(from, fromCtx, _, _).

// specified flows between parameters
FlowFromEdge(to, toCtx, from, fromCtx, "normal") :-
    CallGraphEdge(invo, _, meth, _),
    ParamToParamFlow(toIdx, fromIdx, meth),
    ActualParam(toIdx, invo, to),
    ActualParam(fromIdx, invo, from),
    VarPointsTo(to, toCtx, _, _),
    VarPointsTo(from, fromCtx, _, _).

// inter-procedural flows
FlowFromEdge(to, toCtx, from, fromCtx, "normal") :-
    InterProcAssign(to, toCtx, from, fromCtx).

// inner-procedural flows
FlowFromEdge(to, toCtx, from, fromCtx, "normal") :-
    (AssignVar(to, from); AssignGlobal(to, from); LoadIndex(to, from, _); StoreIndex(to, _, from); 
    LoadField(to, from, _); StoreField(to, _, from); LoadSlice(to, from, _, _, _); StoreSlice(to, _, _, _, from);
    StoreIndexSSA(to, _, _, from); StoreFieldSSA(to, _, _, from); StoreSliceSSA(to, _, _, _, _, from);
    StoreIndexSSA(to, from, _, _); StoreFieldSSA(to, from, _, _); StoreSliceSSA(to, from, _, _, _, _)),
    VarPointsTo(to, toCtx, _, _),
    VarPointsTo(from, fromCtx, _, _).

FlowFromEdge(to, toCtx, left, leftCtx, "normal"),
FlowFromEdge(to, toCtx, right, rightCtx, "normal") :-
    AssignBinOp(to, left, _, right),
    VarPointsTo(to, toCtx, _, _), VarPointsTo(left, leftCtx, _, _), VarPointsTo(right, rightCtx, _, _).

// in-place updates will trigger flow to aliases
FlowFromEdge(from, fromCtx, to, toCtx,  "normal"),
FlowFromEdge(from, fromCtx, to, toCtx,  "equiv") :-
    (StoreIndexSSA(to, mid, _, _); StoreFieldSSA(to, mid, _, _); StoreSliceSSA(to, mid, _, _, _, _)),
    VarPointsTo(to, toCtx, value, hctx),
    VarPointsTo(mid, midCtx, value, hctx),
    VarPointsTo(from, fromCtx, value, hctx).
FlowFromEdge(to, toCtx, from, fromCtx, "normal"),
FlowFromEdge(to, toCtx, from, fromCtx,  "equiv") :-
    CallGraphEdge(invo, _, meth, _),
    MethodUpdate(fromIdx, meth),
    ActualParam(fromIdx, invo, from),
    VarPointsTo(to, toCtx, value, hctx),
    VarPointsTo(from, fromCtx, value, hctx).

// self-loop
FlowFromEdge(from, fromCtx, from, fromCtx, "normal"),
FlowFromEdge(from, fromCtx, from, fromCtx, "equiv")  :-
    VarPointsTo(from, fromCtx, _, _).

// other known equivalent flows
FlowFromEdge(to, toCtx, from, fromCtx, "equiv") :-
    FlowFromEdge(to, toCtx, from, fromCtx, "normal"),
    (StoreIndexSSA(to, from, _, _); StoreFieldSSA(to, from, _, _); StoreSliceSSA(to, from, _, _, _, _);
    InterProcAssign(to, _, from, _); AssignVar(to, from)).

FlowFromEdge(to, toCtx, from, fromCtx, "equiv") :-
    FlowFromEdge(to, toCtx, from, fromCtx, "normal"),
    LoadField(to, from, f),
    (f = "loc"; f = "values"). // should also add type requirement [TODO]

FlowFromEdge(to, toCtx, from, fromCtx, "equiv") :-
    FlowFromEdge(to, toCtx, from, fromCtx, "normal"),
    LoadIndex(to, from, _). // should restrict it to column indexing [TODO]

// marked equivalent flows
FlowFromEdge(to, toCtx, from, fromCtx, "equiv") :-
    FlowFromEdge(to, toCtx, from, fromCtx, "normal"),
    CallGraphEdge(invo, _, meth, _),
    ParamToRetEquivFlow(toIdx, fromIdx, meth),
    ActualParam(fromIdx, invo, from),
    ActualReturn(toIdx, invo, to).
FlowFromEdge(to, toCtx, from, fromCtx, "equiv") :-
    FlowFromEdge(to, toCtx, from, fromCtx, "normal"),
    CallGraphEdge(invo, _, meth, _),
    ParamToRetCondEquivFlow(toIdx, fromIdx, cond_id, meth),
    FlowCondition(cond_id, keyword, content),
    ActualKeyParam(keyword, invo, var),
    ConstantValue(var, content),
    ActualParam(fromIdx, invo, from),
    ActualReturn(toIdx, invo, to).
FlowFromEdge(to, toCtx, from, fromCtx, "equiv") :-
    FlowFromEdge(to, toCtx, from, fromCtx, "normal"),
    CallGraphEdge(invo, _, meth, _),
    ParamContentToRetCondEquivFlow(toIdx, fromIdx, cond_id, meth),
    FlowCondition(cond_id, keyword, content),
    ActualKeyParam(keyword, invo, var),
    ConstantValue(var, content),
    ActualParam(fromIdx, invo, fromList),
    VarPointsTo(fromList, toCtx, fromListValue, baseHctx),
    VarPointsTo(from, fromCtx, fromValue, hctx),
    IndexContentPointsTo(fromListValue, baseHctx, fromValue, hctx),
    ActualReturn(toIdx, invo, to).

// flows between data
// now we assume all flows are between data, except for known model variables
NonDataTransferEdge(to, from) :-
    ParamToRetFlowFilterMethod(to_idx, from_idx, meth),
    CallGraphEdge(invo, _, meth, _),
    ActualParam(from_idx, invo, from),
    ActualReturn(to_idx, invo, to).

FlowFromEdge(to, toCtx, from, fromCtx, "data") :-
    !NonDataTransferEdge(to, from),
    !IsModel(to), !IsModel(from), 
    FlowFromEdge(to, toCtx, from, fromCtx, "normal").

// flow path base case
FlowFrom(to, toCtx, from, fromCtx, tag) :-
    FlowFromEdge(to, toCtx, from, fromCtx, tag).

// flow path transitive case
FlowFrom(to, toCtx, from, fromCtx, tag) :-
    FlowFrom(to, toCtx, mid, midCtx, tag),
    FlowFrom(mid, midCtx, from, fromCtx, tag).

// [deprecated]
FlowFromExtended(to, toCtx, from, fromCtx, tag) :-
    FlowFrom(to, toCtx, from, fromCtx, tag).

// FlowFromExtended(to, toCtx, from, fromCtx, "data"),
// FlowFromExtended(to, toCtx, from, fromCtx, "equiv") :-
//     VarPointsTo(to, toCtx, value, hctx),
//     VarPointsTo(from, fromCtx, value, hctx),
//     !IsModel(to), !IsModel(from).

// FlowFromExtended(to, toCtx, from, fromCtx, "normal") :-
//     VarPointsTo(to, toCtx, value, hctx),
//     VarPointsTo(from, fromCtx, value, hctx).

// FlowFromExtended(to, from, "data"),
// FlowFromExtended(to, from, "equiv"),
// FlowFromExtended(to, from, "normal") :-
//     VarPointsTo(to, baseValue),
//     IndexContentPointsTo(baseValue, _, value),
//     VarPointsTo(from, value).


// FlowFromExtended(to, from, "data"),
// FlowFromExtended(to, from, "equiv"),
// FlowFromExtended(to, from, "normal") :-
//     VarPointsTo(to, baseValue),
//     FieldPointsTo(baseValue, _, value),
//     VarPointsTo(from, value).

// FlowFromExtended(to, toCtx, from, fromCtx, tag) :-
//     FlowFromExtended(to, toCtx, mid, midCtx, tag),
//     FlowFromExtended(mid, midCtx, from, fromCtx, tag).


/* -----------------------------
Overlap analysis
----------------------------- */
.decl DataOverlap(train:Var, ctx1:Context, test:Var, ctx2:Context)
.decl ModelOverlap(model1:Var, ctx1:Context, model2:Var, ctx2:Context)
DataOverlap(train, ctx1, test, ctx2) :- // split with slicing will never be recognized as overlaps
    FlowFromExtended(test, ctx2, src_equiv, ctx_src, "data"), 
    FlowFromExtended(train, ctx1, src_equiv, ctx_src, "equiv").

// [TODO] Overlap in fields/contents
DataOverlap(train, ctx1, test, ctx2) :- DataOverlap(test, ctx2, train, ctx1).

DataOverlap(train, ctx1, test, ctx2) :-
    DuplicateEdge(to, toCtx, _, _),
    FlowFromExtended(train, ctx1, to, toCtx, "data"),
    FlowFromExtended(test, ctx2, to, toCtx, "data").

DataOverlap(train, ctx1, test, ctx2) :-
    DuplicateEdge(to, toCtx, from, fromCtx),
    FlowFromExtended(train, ctx1, to, toCtx, "data"),
    DataOverlap(test, ctx2, from, fromCtx).

DataOverlap(train, ctx1, test, ctx2) :-
    DuplicateEdge(to, toCtx, from, fromCtx),
    FlowFromExtended(test, ctx2, to, toCtx, "data"),
    DataOverlap(train, ctx1, from, fromCtx).

// check whether two models are related
ModelOverlap(model1, ctx1, model2, ctx2) :-
    IsModel(model1), IsModel(model2),
    FlowFromExtended(model1, ctx1, model2, ctx2, _).
ModelOverlap(model2, ctx2, model1, ctx1) :- ModelOverlap(model1, ctx1, model2, ctx2).


/* -----------------------------
Training/validation/test data rules
----------------------------- */
.decl TrainingDataWithModel(model:Var, train:Var, invo:Invocation, meth:Method)
.decl ValOrTestDataWithModel(model:Var, test:Var, invo:Invocation, meth:Method)
.decl ScoredDataWithModel(model:Var, test:Var, invo:Invocation, meth:Method)
.decl TestDataWithModel(model:Var, test:Var, invo:Invocation, meth:Method)
.decl ValDataWithModel(model:Var, val:Var, invo:Invocation, meth:Method)
.decl TrainTestPair(trainModel:Var, train:Var, testModel:Var, test:Var)
.decl TrainValPair(trainModel:Var, train:Var, valModel:Var, val:Var)
.decl IsModel(model:Var)

IsModel(model) :- 
    TrainingDataWithModel(model, _, _, _); ValOrTestDataWithModel(model, _, _, _).

TrainingDataWithModel(model, train, invo, meth) :-
    (TrainingData(meth, model_idx, idx),
    ActualParam(idx, invo, train);
    TrainingDataByKey(meth, model_idx, keyword),
    ActualKeyParam(keyword, invo, train)),
    CallGraphEdge(invo, _, meth, _),
    !FilteredTrainingMethod(meth),
    ActualParam(model_idx, invo, model).

// could be test/validation data; to be determined
ValOrTestDataWithModel(model, test, invo, meth) :-
    (TestData(meth, model_idx, idx),
    ActualParam(idx, invo, test);
    TestDataByKey(meth, model_idx, keyword),
    ActualKeyParam(keyword, invo, test)),
    CallGraphEdge(invo, _, meth, _),
    ActualParam(model_idx, invo, model).

// find test/validation data used to compute scores
// [Case 1] score functions called upon models
ScoredDataWithModel(model, test, invo, meth) :-
    ValOrTestDataWithModel(model, test, invo, meth),
    ScoredData(meth, model_idx, idx),
    ActualParam(idx, invo, test),
    ActualParam(model_idx, invo, model).
// [Case 2] prediction results are used to compute scores
ScoredDataWithModel(model, test, invo, meth) :-
    ValOrTestDataWithModel(model, test, invo, meth),
    ActualReturn(ret_idx, invo, ret),
    ret_idx = 0,
    FlowFromExtended(res, ctx2, ret, ctx1, _),
    ScoredResult(meth2, res_idx),
    CallGraphEdge(invo2, ctx2, meth2, _),
    CallGraphEdge(invo, ctx1, meth, _),
    ActualParam(res_idx, invo2, res).

// validation data rules
// [Case 1] Specified method arguments that are used for validation 
ValDataWithModel(model, val, invo, meth) :-
    (ValData(meth, model_idx, idx),
    ActualParam(idx, invo, val);
    ValDataByKey(meth, model_idx, keyword),
    ActualKeyParam(keyword, invo, val)),
    CallGraphEdge(invo, _, meth, _),
    ActualParam(model_idx, invo, model).
ValDataWithModel(model, val, invo, meth) :-
    ValDataByKey(meth, model_idx, keyword),
    keyword = "validation_data",
    ActualKeyParam(keyword, invo, tup),
    StoreIndex(tup, "0", val),
    CallGraphEdge(invo, _, meth, _),
    ActualParam(model_idx, invo, model).
// [Case 2] Invoke multiple times in a loop
ValDataWithModel(model, val, invo, meth) :-
    ValOrTestDataWithModel(model, val, invo, meth),
    InvokeInLoop(invo).
// [Case 3] Scored multiple times for different models
// [TODO] exactly the same, or overlapping data?
ValDataWithModel(testModel, val, invo, meth),
ValDataWithModel(testModel2, val, invo2, meth2) :-
    ScoredDataWithModel(testModel, val, invo, meth),
    ScoredDataWithModel(testModel2, val, invo2, meth2),
    invo != invo2,
    !ModelOverlap(testModel, _, testModel2, _).
// [Case 4] propagation to overlapping data
ValDataWithModel(model, test, invo, meth) :-
    ValOrTestDataWithModel(model, test, invo, meth),
    ValDataWithModel(testModel, val, invo, meth),
    ModelOverlap(model, ctx1, testModel, ctx2),
    DataOverlap(test, ctx1, val, ctx2).

// all remaining data is treated as validation data
TestDataWithModel(model, test, invo, meth) :-
    ValOrTestDataWithModel(model, test, invo, meth),
    !ValDataWithModel(model, test, invo, meth).

// Pairing train/test, train/val data
// We assume there should be no data overlapping
TrainTestPair(trainModel, train, testModel, test) :-
    TestDataWithModel(testModel, test, _, _),
    TrainingDataWithModel(trainModel, train, _, _),
    !DataOverlap(test, ctx1, train, ctx2),
    ModelOverlap(testModel, ctx1, trainModel, ctx2).
TrainValPair(trainModel, train, valModel, val) :-
    ValDataWithModel(valModel, val, _, _),
    TrainingDataWithModel(trainModel, train, _, _),
    !DataOverlap(val, ctx1, train, ctx2),
    ModelOverlap(valModel, ctx1, trainModel, ctx2).

/* -----------------------------
Leak detection rules
----------------------------- */
.decl Leak(var:Var, invo:Invocation, meth:Method)
.decl PreProcessingLeak(var:Var, invo:Invocation, meth:Method)
.decl OverlapLeak(testModel:Var, trainModel:Var, invo:Invocation, meth:Method)

Leak(var, invo, meth) :-
    PreProcessingLeak(var, invo, meth);
    OverlapLeak(_, var, invo, meth).

// General edges/taints
// Taints are initialized at places where pre-processing leak might happen
.decl TaintStarts(var:Var, ctx: Context, label:symbol)
.decl TaintStartsTarget(to:Var, toCtx:Context, from:Var, fromCtx:Context, label:symbol)

TaintStarts(var, callerCtx, label) :-
    CallGraphEdge(invo, callerCtx, meth, _),
    RetTaintSourceMethod(idx, meth, label),
    ActualReturn(idx, invo, var).

TaintStarts(var, callerCtx, label),
TaintStartsTarget(target, callerCtx, var, callerCtx, label) :-
    CallGraphEdge(invo, callerCtx, meth, _),
    (ParamToParamTaintSourceMethod(toIdx, fromIdx, meth, label), ActualParam(toIdx, invo, target);
    ParamToRetTaintSourceMethod(toIdx, fromIdx, meth, label), ActualReturn(toIdx, invo, target);
    ParamToRetCondTaintSourceMethod(toIdx, fromIdx, cond_id, meth, label), TaintCondition(cond_id, srcIdx, srcTaintType),
    ActualParam(srcIdx, invo, src), FlowFrom(src, callerCtx, src_start, src_start_ctx, _), TaintStarts(src_start, src_start_ctx, srcTaintType), ActualReturn(toIdx, invo, target)),
    ActualParam(fromIdx, invo, var).

/* -----------------------------
Pre-processing leak detection
----------------------------- */
.decl ReduceEdge(to:Var, toCtx:Context, from:Var, fromCtx:Context)
ReduceEdge(to, toCtx, from, fromCtx) :-
    TaintStartsTarget(to, toCtx, from, fromCtx, "rowset").

PreProcessingLeak(src, invo, meth) :-
    (TrainTestPair(trainModel, train, testModel, test); TrainValPair(trainModel, train, testModel, test)),
    TrainingDataWithModel(trainModel, train, invo, meth),
    // TestDataWithModel(testModel, test, _, _),
    ReduceEdge(reduced_from_src, r_ctx, src, src_ctx),
    (FlowFromExtended(train, _, reduced_from_src, r_ctx, _); FlowFromExtended(test, ctx1, reduced_from_src, r_ctx, _)),
    DataOverlap(test, ctx1, src, src_ctx).

/* -----------------------------
Overlap leak detection
----------------------------- */
.decl DuplicateEdge(to:Var, toCtx:Context, from:Var, fromCtx:Context)

DuplicateEdge(to, toCtx, from, fromCtx) :-
    TaintStartsTarget(to, toCtx, from, fromCtx, "dup").

OverlapLeak(testModel, trainModel, invo, meth) :-
    TrainingDataWithModel(trainModel, train, invo, meth),
    ValOrTestDataWithModel(testModel, test, _, _),
    DataOverlap(train, _, test, _),
    train != test,
    ModelOverlap(trainModel, _, testModel, _).

/* -----------------------------
No test data detection
----------------------------- */
.decl NoValAndTestData(trainModel:Var, invo:Invocation, meth:Method)
.decl NoTestData(trainModel:Var, invo:Invocation, meth:Method)

NoValAndTestData(trainModel, invo, meth) :-
    TrainingDataWithModel(trainModel, train, invo, meth),
    !TrainValPair(trainModel, train, _, _),
    !TrainTestPair(trainModel, train, _, _).

NoTestData(trainModel, invo, meth) :-
    TrainingDataWithModel(trainModel, train, invo, meth),
    TrainValPair(trainModel, train, _, _),
    !TrainTestPair(trainModel, train, _, _).

/* -----------------------------
Multi-used test data detection
----------------------------- */
.decl MultiUseTestLeak(test:Var, invo:Invocation, meth:Method)
MultiUseTestLeak(test, invo, meth) :-
    TestDataWithModel(testModel, test, invo, meth),
    ScoredDataWithModel(testModel, test, invo, meth),
    TestDataWithModel(testModel2, test2, invo2, meth2),
    ScoredDataWithModel(testModel2, test2, invo2, meth2),
    invo != invo2,
    DataOverlap(test, _, test2, _).

// ---- outputs ----
.output CallGraphEdge
.output TrainTestPair
.output TrainValPair
.output TestDataWithModel
.output ValDataWithModel
.output ScoredDataWithModel
.output FlowFromEdge
.output FlowFrom
.output FlowFromExtended
.output TaintStartsTarget
.output VarPointsTo
.output FieldPointsTo
.output IndexContentPointsTo
.output DataOverlap
.output ModelOverlap
.output PreProcessingLeak
.output OverlapLeak
.output NoTestData
.output NoValAndTestData
.output MultiUseTestLeak