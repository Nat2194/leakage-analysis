.type Var <: symbol
.type Type <: symbol
.type Field <: symbol
.type Index <: symbol
.type Invocation <: symbol
.type Method <: symbol
.type Value <: symbol

#define ValueIdMacro(id, type) \
    cat(cat(cat(id, "::: "), type), "::: ")

// -- inputs --
// inner-procedural facts
.decl AssignVar(to:Var, from:Var)
.decl AssignStrConstant(to:Var, constant:symbol)
.decl AssignBoolConstant(to:Var, constant:symbol)
.decl AssignBinOp(to:Var, left:Var, op:symbol, right:Var)
.decl LoadField(to:Var, base:Var, f:Field)
.decl StoreField(base:Var, f:Field, from:Var)
.decl LoadIndex(to:Var, base:Var, i:Index)
.decl StoreIndex(base:Var, i:Index, from:Var)
.decl LoadSlice(to:Var, base:Var, st:Var, ed:Var, step:Var)
.decl StoreSlice(to:Var, st:Var, ed:Var, step:Var, base:Var)

// inter-procedural facts
// .decl Invoke(invo:Invocation)
.decl ActualParam(index:number, invo:Invocation, var:Var)
.decl FormalParam(index:number, meth:Method, var:Var)
.decl ActualKeyParam(keyword:Var, invo:Invocation, var:Var)
// .decl FormalKeyParam(keyword:Var, meth:Method)
.decl ActualReturn(index:number, invo:Invocation, var:Var)
.decl FormalReturn(index:number, meth:Method, var:Var)
.decl CallGraphEdge(invo:Invocation, meth:Method)
// .decl MethodUpdate(meth:Method, index:number)
.decl VarType(var:Var, type:Type)
.decl Alloc(var:Var, value:Value)
.decl LocalMethod(meth:Method)
.decl LocalClass(cls:Type)
.decl InvokeInLoop(invo:Invocation)

.input AssignVar
.input AssignStrConstant
.input AssignBoolConstant
.input AssignBinOp
.input LoadField
.input StoreField
.input LoadIndex
.input StoreIndex
.input LoadSlice
.input StoreSlice

.input ActualParam
.input FormalParam
.input ActualKeyParam
.input ActualReturn
.input FormalReturn
.input CallGraphEdge
.input VarType
.input Alloc
.input LocalMethod
.input LocalClass
.input InvokeInLoop



// taint analysis input relations
.decl ParamToRetTaintSourceMethod(to:number, from:number, method:Method, taintType:symbol)
.decl ParamToParamTaintSourceMethod(to:number, from:number, method:Method, taintType:symbol)
.decl RetTaintSourceMethod(retIndex:number, method:Method, taintType:symbol)
.decl ParamToRetCondTaintSourceMethod(to:number, from:number, cond_id:number, method:Method, taintType:symbol)
.decl ParamToParamCondTaintSourceMethod(to:number, from:number, cond_id:number, method:Method, taintType:symbol)
.decl TaintCondition(cond_id:number, src_idx:number, taintType:symbol)

.decl ParamToRetFlowFilterMethod(to:number, from:number, method:Method)
// .decl ParamToParamTaintTransferMethod(to:number, from:number, method:Method)
// .decl ParamToRetTaintTransferMethod(to:number, from:number, method:Method)
// .decl ParamKeyToRetTaintTransferMethod(to:number, from:Var, method:Method)


// .decl TaintSourceRetMethod(method:Method, index:number, taintType:symbol)
// .decl TaintSourceSetRetMethod(method:Method, to:number, from:number, taintType:symbol)
// .decl SinkMethod(method:Method, index:number, label:symbol)
// .decl ParamToParamSetTaintTransferMethod(to:number, from:number, method:Method)
// .decl ParamToRetSetTaintTransferMethod(to:number, from:number, method:Method)

// // heap flow analysis facts
// .decl ParamToRetSubsetMethod(to:number, from:number, method:Method)
// .decl ParamToRetEquivMethod(to:number, from:number, method:Method)


// -- facts --

ParamToParamFlow(0, 1, "pandas.Series.fillna").
ParamToRetFlowFilterMethod(0, 0, meth) :-
    CallGraphEdge(_, meth),
    match(".*[.](fit|fit_transform|transform)", meth).

ParamToRetEquivFlow(0, 0, "ndarray.reshape").
ParamToRetEquivFlow(0, 0, "pandas.Series.fillna").
// ParamToRetEquivFlow(0, 0, "pandas.Series.drop").
// ParamToRetEquivFlow(0, 0, "pandas.DataFrame.drop").
ParamToRetEquivFlow(0, 1, "pandas.DataFrame").
ParamToRetEquivFlow(0, 1, "pandas.concat").
ParamToRetEquivFlow(0, 1, "pandas.get_dummies").
ParamToRetEquivFlow(0, 1, "numpy.array").
ParamToRetEquivFlow(0, 1, "sklearn.preprocessing.scale").
ParamToRetEquivFlow(0, 0, meth) :-
    CallGraphEdge(_, meth),
    match(".*[.](astype)", meth).

ParamToRetEquivFlow(0, 0, meth) :-
    CallGraphEdge(_, meth),
    match(".*[.](toarray)", meth).

ParamToRetEquivFlow(0, 1, meth) :-
    CallGraphEdge(_, meth),
    match(".*[.](transform|fit_transform)", meth).


ParamToRetTaintSourceMethod(0, 1, meth, "rowset") :-
    CallGraphEdge(_, meth),
    match("numpy[.](nan)?(average|median|mean|std|var)", meth).
// ParamToRetTaintSourceMethod(0, 0, "Unknown.mean", "rowset").
ParamToRetTaintSourceMethod(0, 1, "pandas.cut", "rowset").
ParamToRetTaintSourceMethod(0, 1, "pandas.qcut", "rowset").
ParamToRetTaintSourceMethod(0, 0, meth, "rowset") :-
    CallGraphEdge(_, meth),
    match(".*(Unknown|Series|DataFrame|FrameOrSeries)[.](groupby|corr|cov|mode|mean|median|std|sum|describe)", meth). // some of them actually depends on the axis
ParamToRetTaintSourceMethod(0, 0, ".*[.]DataFrame.groupby", "rowset").
ParamToRetTaintSourceMethod(0, 1, "sklearn.preprocessing.scale", "rowset"). 
// sklearn.preprocessing.normalize when axis = 1

// pre-processing leaks 
ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset") :-
    CallGraphEdge(_, meth),
    match("(KBinsDiscretizer|PowerTransformer|QuantileTransformer|MaxAbsScaler|StandardScaler|MinMaxScaler|RobustScaler)[.]fit_transform", meth). 

ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset")  :-
    CallGraphEdge(_, meth),
    match("(KBinsDiscretizer|PowerTransformer|QuantileTransformer|MaxAbsScaler|StandardScaler|MinMaxScaler|RobustScaler)[.]fit", meth).

// imputer leaks (depends on the strategy)
ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset") :-
    CallGraphEdge(_, meth),
    match("(Imputer|SimpleImputer|IterativeImputer|KNNImputer)[.]fit_transform", meth). 

ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset")  :-
    CallGraphEdge(_, meth),
    match("(Imputer|SimpleImputer|IterativeImputer|KNNImputer)[.]fit", meth).

// feature selection leaks
ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset") :-
    CallGraphEdge(_, meth),
    match("(GenericUnivariateSelect|SelectPercentile|SelectKBest|SelectFpr|SelectFdr|SelectFromModel|SelectFwe|SequentialFeatureSelector|RFE|RFECV|VarianceThreshold)[.]fit_transform", meth). 

ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset")  :-
    CallGraphEdge(_, meth),
    match("(GenericUnivariateSelect|SelectPercentile|SelectKBest|SelectFpr|SelectFdr|SelectFromModel|SelectFwe|SequentialFeatureSelector|RFE|RFECV|VarianceThreshold)[.]fit", meth). 

// other leaks
ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset") :-
    CallGraphEdge(_, meth),
    match("(CountVectorizer|HashingVectorizer|TfidfTransformer|TfidfVectorizer|PCA)[.]fit_transform", meth). 

ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset")  :-
    CallGraphEdge(_, meth),
    match("(CountVectorizer|HashingVectorizer|TfidfTransformer|TfidfVectorizer|PCA)[.]fit", meth).

// pipeline leaks
RetTaintSourceMethod(0, "sklearn.preprocessing.Imputer", "pipeline"). // not always a problem, be conservative
RetTaintSourceMethod(0, "sklearn.preprocessing.MinMaxScaler", "pipeline"). 

ParamToRetCondTaintSourceMethod(0, 1, 4027, "DataFrameMapper.fit_transform", "rowset"). 
ParamToRetCondTaintSourceMethod(0, 1, 4027, "Pipeline.fit_transform",  "rowset").
TaintCondition(4027, 0, "pipeline").

ParamToRetTaintSourceMethod(0, 1, "ImageDataGenerator.flow", "dup"). 


// train/test locations
.decl TrainingData(method:Method, model_idx:number, data_index:number)
.decl TrainingDataByKey(method:Method, model_idx:number, datakw:Var)
.decl TestData(method:Method, model_idx:number, data_index:number)
.decl TestDataByKey(method:Method, model_idx:number, datakw:Var)
.decl ValData(method:Method, model_idx:number, data_index:number)
.decl ValDataByKey(method:Method, model_idx:number, datakw:Var)
.decl ScoredData(method:Method, model_idx:number, data_index:number)
.decl ScoredResult(method:Method, result_index:number)
.decl FilteredTrainingMethod(method:Method)

TrainingData(meth, 0, 1) :-
    CallGraphEdge(_, meth),
    match(".*[.](fit|fit_generator)", meth).

TrainingDataByKey(meth, 0, "generator") :-
    CallGraphEdge(_, meth),
    match(".*[.](fit_generator)", meth).

TestData(meth, 0, 1) :-
    CallGraphEdge(_, meth),
    match(".*[.](predict|score|evaluate|predict_proba)", meth).

TestDataByKey(meth, 0, "x") :-
    CallGraphEdge(_, meth),
    match(".*[.](predict_proba)", meth).

ValData(meth, 0, 1) :-
    CallGraphEdge(_, meth),
    match(".*(GridSearchCV|HalvingGridSearchCV|ParameterGrid|ParameterSampler|RandomizedSearchCV|HalvingRandomSearchCV)[.]fit", meth).

ValDataByKey(meth, 0, "validation_data") :-
    CallGraphEdge(_, meth),
    match(".*[.](fit|fit_generator)", meth).

ScoredData(meth, 0, 1) :-
    CallGraphEdge(_, meth),
    match(".*[.](score|evaluate)", meth).

// ???
ScoredResult(meth, 2) :-
    CallGraphEdge(_, meth),
    match(".*(accuracy_score|balanced_accuracy_score|top_k_accuracy_score|average_precision_score|brier_score_loss|f1_score|f1_score|f1_score|f1_score|f1_score|log_loss|precision_score|recall_score|jaccard_score|roc_auc_score|roc_auc_score|roc_auc_score|roc_auc_score|roc_auc_score|adjusted_mutual_info_score|adjusted_rand_score|completeness_score|fowlkes_mallows_score|homogeneity_score|mutual_info_score|normalized_mutual_info_score|rand_score|v_measure_score|explained_variance_score|max_error|mean_absolute_error|mean_squared_error|mean_squared_error|mean_squared_log_error|median_absolute_error|r2_score|mean_poisson_deviance|mean_gamma_deviance|mean_absolute_percentage_errors)", meth).

FilteredTrainingMethod(meth) :-
    CallGraphEdge(_, meth),
    (match("(GenericUnivariateSelect|SelectPercentile|SelectKBest|SelectFpr|SelectFdr|SelectFromModel|SelectFwe|SequentialFeatureSelector|RFE|RFECV|VarianceThreshold)[.]fit", meth);
    match("(CountVectorizer|HashingVectorizer|TfidfTransformer|TfidfVectorizer|PCA)[.]fit", meth);
    match("(Imputer|SimpleImputer|IterativeImputer|KNNImputer)[.]fit", meth);
    match("(KBinsDiscretizer|PowerTransformer|QuantileTransformer|MaxAbsScaler|StandardScaler|MinMaxScaler|RobustScaler)[.]fit", meth)).
 
// TrainingData("LogisticRegression.fit", 0, 1).
// TrainingData("GaussianNB.fit", 0, 1).
// TrainingData("Unknown.fit", 0, 1).
// TrainingData("Model.fit", 0, 1).
// TrainingData("Sequential.fit", 0, 1).

// TestData("LogisticRegression.predict", 0, 1).
// TestData("GaussianNB.predict", 0, 1).
// TestData("Unknown.predict_proba", 0, 1).
// TestData("Unknown.score", 0, 1).
// TestData("Model.evaluate", 0, 1).
// TestData("Sequential.evaluate", 0, 1).

// ParamToRetTaintTransferMethod(0, 1, "pandas.Series.fillna").
// ParamToParamTaintTransferMethod(0, 1, "pandas.Series.fillna").
// ParamToRetTaintTransferMethod(0, 0, "PCA.transform").
// ParamToRetTaintTransferMethod(0, 0, "SelectPercentile.transform").
// ParamToRetTaintTransferMethod(0, 1, "DataFrameMapper").
// ParamToRetTaintTransferMethod(0, 1, "Pipeline").
// ParamKeyToRetTaintTransferMethod(0, "transformer_list", "FeatureUnion").
// ParamToRetTaintTransferMethod(0, 1, "RandomizedSearchCV").

// ParamToRetSubsetMethod(0, 1, meth),
// ParamToRetSubsetMethod(1, 1, meth),
// ParamToRetSubsetMethod(2, 2, meth),
// ParamToRetSubsetMethod(3, 2, meth) :-
//     CallGraphEdge(_, meth),
//     match(".*train_test_split", meth).



// ---- pointer analysis ----

.decl VarPointsTo(var:Var, value:Value)
.decl IndexContentPointsTo(baseValue:Value, value:Value)
.decl FieldPointsTo(base:Value, field:Field, value:Value)
.decl InterProcAssign(to:Var, from:Var)

// .decl TaintSource(taintValue:Value, srcValue:Value, taintType:symbol)
// .decl TaintFrom(to:Var, from:Var)

// .decl IsHeapObject(value:Value)
// .decl IsTaintObject(value:Value)

VarPointsTo(var, value) :- Alloc(var, value).
VarPointsTo(to, value) :- 
    AssignVar(to, from),
    VarPointsTo(from, value).
VarPointsTo(to, value) :- 
    LoadIndex(to, base, _),
    VarPointsTo(base, value). 
VarPointsTo(to, value) :- 
    LoadIndex(to, base, _),
    VarPointsTo(base, baseValue),
    IndexContentPointsTo(baseValue, value).    
IndexContentPointsTo(baseValue, value) :- 
    StoreIndex(base, _, from),
    VarPointsTo(base, baseValue),
    VarPointsTo(from, value).
VarPointsTo(to, value) :- 
    LoadField(to, base, _),
    VarPointsTo(base, value).
// VarPointsTo(base, value) :- 
//     StoreField(base, _, from),
//     VarPointsTo(from, value).
VarPointsTo(to, value) :- 
    LoadField(to, base, fld),
    VarPointsTo(base, baseValue),
    FieldPointsTo(baseValue, fld, value).
FieldPointsTo(baseValue, fld, value) :-
    StoreField(base, fld, from),
    VarPointsTo(base, baseValue),
    VarPointsTo(from, value).

VarPointsTo(to, value) :- 
    LoadSlice(to, from, _, _, _),
    VarPointsTo(from, value).
VarPointsTo(to, value) :- 
    LoadSlice(to, base, _, _, _),
    VarPointsTo(base, baseValue),
    IndexContentPointsTo(baseValue, value).  
IndexContentPointsTo(baseValue, value) :- 
    StoreSlice(base, _, _, _, from),
    VarPointsTo(base, baseValue),
    VarPointsTo(from, value).

InterProcAssign(to, from) :-
    CallGraphEdge(invo, meth),
    meth != "__phi__",
    FormalParam(index, meth, to),
    ActualParam(index, invo, from).

InterProcAssign(to, from) :-
    CallGraphEdge(invo, meth),
    meth != "__phi__",
    FormalParam(_, meth, to),
    ActualKeyParam(to, invo, from).

InterProcAssign(to, from) :-
    CallGraphEdge(invo, meth),
    meth != "__phi__",
    FormalReturn(index, meth, from),
    ActualReturn(index, invo, to).

VarPointsTo(to, value) :- 
    InterProcAssign(to, from),
    VarPointsTo(from, value).
    // IsHeapObject(value).

// IsHeapObject(value) :-
//     Alloc(_, value).

// IsHeapSubset(subset, set) :-
//     ActualParam(fromIndex, invo, from),
//     VarPointsTo(from, set),
//     IsHeapObject(set),
//     ActualReturn(toIndex, invo, to),
//     VarPointsTo(to, subset),
//     IsHeapObject(subset),
//     CallGraphEdge(invo, meth),
//     ParamToRetSubsetMethod(toIndex, fromIndex, meth).

// IsHeapSubset(subset, set) :-
//     IsHeapSubset(subset, middleset),
//     IsHeapSubset(middleset, set).


// ---- data flow analysis ----
.decl FlowFrom(to:Var, from:Var, tag:symbol)
.decl FlowFromEdge(to:Var, from:Var, tag:symbol)
.decl FlowFromExtended(to:Var, from:Var, tag:symbol)
.decl ParamToParamFlow(to:number, from:number, method:Method) // input facts
.decl ParamToRetEquivFlow(to:number, from:number, method:Method) 
.decl NonDataTransferEdge(to:Var, from:Var)

FlowFromEdge(to, from, "normal") :-
    CallGraphEdge(invo, meth),
    (ActualParam(_, invo, from); ActualKeyParam(_, invo, from)),
    ActualReturn(_, invo, to),
    (!LocalMethod(meth); meth = "__phi__").

FlowFromEdge(to, from, "normal") :-
    CallGraphEdge(invo, meth),
    ParamToParamFlow(toIdx, fromIdx, meth),
    ActualParam(toIdx, invo, to),
    ActualParam(fromIdx, invo, from).

FlowFromEdge(to, from, "normal") :-
    InterProcAssign(to, from); AssignVar(to, from); LoadIndex(to, from, _); StoreIndex(to, _, from); 
    LoadField(to, from, _); StoreField(to, _, from); LoadSlice(to, from, _, _, _).

FlowFromEdge(to, left, "normal"),
FlowFromEdge(to, right, "normal") :-
    AssignBinOp(to, left, _, right).

FlowFromEdge(to, from, "equiv") :-
    InterProcAssign(to, from); AssignVar(to, from).

FlowFromEdge(to, from, "equiv") :-
    LoadField(to, from, f),
    (f = "loc"; f = "values"). // should also add type requirement [TODO]

FlowFromEdge(to, from, "equiv") :-
    LoadIndex(to, from, _). // should also add type requirement [TODO]

FlowFromEdge(to, from, "equiv") :-
    CallGraphEdge(invo, meth),
    ParamToRetEquivFlow(toIdx, fromIdx, meth),
    ActualParam(fromIdx, invo, from),
    ActualReturn(toIdx, invo, to).

NonDataTransferEdge(to, from) :-
    ParamToRetFlowFilterMethod(to_idx, from_idx, meth),
    CallGraphEdge(invo, meth),
    ActualParam(from_idx, invo, from),
    ActualReturn(to_idx, invo, to).

FlowFromEdge(to, from, "data") :-
    !NonDataTransferEdge(to, from),
    FlowFromEdge(to, from, "normal").

FlowFrom(to, from, tag) :-
    FlowFromEdge(to, from, tag).

FlowFrom(to, from, tag) :-
    FlowFrom(to, mid, tag),
    FlowFrom(mid, from, tag).


FlowFromExtended(to, from, tag) :-
    FlowFrom(to, from, tag).

FlowFromExtended(to, from, "data"),
FlowFromExtended(to, from, "equiv"),
FlowFromExtended(to, from, "normal") :-
    VarPointsTo(to, value),
    VarPointsTo(from, value).


FlowFromExtended(to, from, "data"),
FlowFromExtended(to, from, "equiv"),
FlowFromExtended(to, from, "normal") :-
    VarPointsTo(to, baseValue),
    IndexContentPointsTo(baseValue, value),
    VarPointsTo(from, value).


FlowFromExtended(to, from, "data"),
FlowFromExtended(to, from, "equiv"),
FlowFromExtended(to, from, "normal") :-
    VarPointsTo(to, baseValue),
    FieldPointsTo(baseValue, _, value),
    VarPointsTo(from, value).

FlowFromExtended(to, from, tag) :-
    FlowFromExtended(to, mid, tag),
    FlowFromExtended(mid, from, tag).

// ---- derived training/validation/test data rules ----
.decl TrainingDataWithModel(model:Var, train:Var, invo:Invocation, meth:Method)
.decl ValOrTestDataWithModel(model:Var, test:Var, invo:Invocation, meth:Method)
.decl ScoredDataWithModel(model:Var, test:Var, invo:Invocation, meth:Method)
.decl TestDataWithModel(model:Var, test:Var, invo:Invocation, meth:Method)
.decl ValDataWithModel(model:Var, val:Var, invo:Invocation, meth:Method)
.decl TrainTestPair(trainModel:Var, train:Var, testModel:Var, test:Var)

// .decl ValTestPair(trainModel:Var, train:Var, testModel:Var, test:Var)

TrainingDataWithModel(model, train, invo, meth) :-
    (TrainingData(meth, model_idx, idx),
    ActualParam(idx, invo, train);
    TrainingDataByKey(meth, model_idx, keyword),
    ActualKeyParam(keyword, invo, train)),
    CallGraphEdge(invo, meth),
    !FilteredTrainingMethod(meth),
    ActualParam(model_idx, invo, model).

// could be both
ValOrTestDataWithModel(model, test, invo, meth) :-
    (TestData(meth, model_idx, idx),
    ActualParam(idx, invo, test);
    TestDataByKey(meth, model_idx, keyword),
    ActualKeyParam(keyword, invo, test)),
    CallGraphEdge(invo, meth),
    ActualParam(model_idx, invo, model).

ScoredDataWithModel(model, test, invo, meth) :-
    ValOrTestDataWithModel(model, test, invo, meth),
    ScoredData(meth, model_idx, idx),
    ActualParam(idx, invo, test),
    ActualParam(model_idx, invo, model).

ScoredDataWithModel(model, test, invo, meth) :-
    ValOrTestDataWithModel(model, test, invo, meth),
    ActualReturn(ret_idx, invo, ret),
    ret_idx = 0,
    FlowFromExtended(res, ret, _),
    ScoredResult(meth2, res_idx),
    CallGraphEdge(invo2, meth2),
    ActualParam(res_idx, invo2, res).

ValDataWithModel(model, val, invo, meth) :-
    (ValData(meth, model_idx, idx),
    ActualParam(idx, invo, val);
    ValDataByKey(meth, model_idx, keyword),
    ActualKeyParam(keyword, invo, val)),
    CallGraphEdge(invo, meth),
    ActualParam(model_idx, invo, model).

ValDataWithModel(model, val, invo, meth) :-
    ValDataByKey(meth, model_idx, keyword),
    keyword = "validation_data",
    ActualKeyParam(keyword, invo, tup),
    StoreIndex(tup, "0", val),
    CallGraphEdge(invo, meth),
    ActualParam(model_idx, invo, model).

ValDataWithModel(model, val, invo, meth) :-
    ValOrTestDataWithModel(model, val, invo, meth),
    InvokeInLoop(invo).

ValDataWithModel(testModel, val, invo, meth),
ValDataWithModel(testModel2, val, invo, meth) :-
    ScoredDataWithModel(testModel, val, invo, meth),
    ScoredDataWithModel(testModel2, val, invo2, meth2),
    invo != invo2,
    DataOverlap(testModel, testModel2).

TestDataWithModel(model, test, invo, meth) :-
    ValOrTestDataWithModel(model, test, invo, meth),
    !ValDataWithModel(model, test, invo, meth). // and there should be no flow between test and val! [TODO]

// ValTestPair(valModel, val, testModel, test) :-
//     TestDataWithModel(testModel, test, _, _),
//     ValDataWithModel(valModel, val, _, _),
//     (val = test; FlowFrom(test, val, _); FlowFrom(val, test, _)),
//     (valModel = testModel; FlowFromExtended(testModel, valModel, _)).

TrainTestPair(trainModel, train, testModel, test) :-
    TestDataWithModel(testModel, test, _, _),
    TrainingDataWithModel(trainModel, train, _, _),
    train != test, !FlowFrom(test, train, _),
    (trainModel = testModel; FlowFromExtended(testModel, trainModel, _)). // how to handle model propagation? [TODO]

// ---- leak detection ----
.decl Leak(var:Var, invo:Invocation, meth:Method)
.decl PreProcessingLeak(var:Var, invo:Invocation, meth:Method)
.decl OverlapLeak(testModel:Var, trainModel:Var, invo:Invocation, meth:Method)


Leak(var, invo, meth) :-
    PreProcessingLeak(var, invo, meth);
    OverlapLeak(_, var, invo, meth).

// General edges/taints
.decl TaintStarts(var:Var, label:symbol)
.decl TaintStartsTarget(var:Var, target:Var, label:symbol)
.decl TaintedVar(var:Var)

TaintStarts(var, label) :-
    CallGraphEdge(invo, meth),
    RetTaintSourceMethod(idx, meth, label),
    ActualReturn(idx, invo, var).

TaintStarts(var, label),
TaintStartsTarget(var, target, label) :-
    CallGraphEdge(invo, meth),
    (ParamToParamTaintSourceMethod(toIdx, fromIdx, meth, label), ActualParam(toIdx, invo, target);
    ParamToRetTaintSourceMethod(toIdx, fromIdx, meth, label), ActualReturn(toIdx, invo, target);
    ParamToRetCondTaintSourceMethod(toIdx, fromIdx, cond_id, meth, label), TaintCondition(cond_id, srcIdx, srcTaintType),
    ActualParam(srcIdx, invo, src), FlowFrom(src, src_start, _), TaintStarts(src_start, srcTaintType), ActualReturn(toIdx, invo, target)),
    ActualParam(fromIdx, invo, var).

TaintedVar(var) :-  
    TaintStarts(var, _).

TaintedVar(to) :-  
    FlowFromExtended(to, from, _),
    TaintedVar(from).


// pre-processing leaks
.decl ReduceEdge(to:Var, from:Var)

ReduceEdge(to, from) :-
    TaintStartsTarget(from, to, "rowset").

PreProcessingLeak(src, invo, meth) :-
    TrainTestPair(trainModel, train, testModel, test),
    TrainingDataWithModel(trainModel, train, invo, meth),
    TestDataWithModel(testModel, test, _, _),
    ReduceEdge(to, src),
    FlowFromExtended(train, to, _),
    (FlowFromExtended(test, src, "data");
    FlowFromExtended(test, src_equiv, "data"), FlowFromExtended(src, src_equiv, "equiv")).

PreProcessingLeak(src, invo, meth) :-
    TrainTestPair(trainModel, train, testModel, test),
    TrainingDataWithModel(trainModel, train, invo, meth),
    TestDataWithModel(testModel, test, _, _),
    ReduceEdge(to, src),
    FlowFromExtended(test, to, "data").

// Overlap detection
.decl DataOverlap(train:Var, test:Var)
.decl DuplicateEdge(to:Var, from:Var)

DuplicateEdge(to, from) :-
    TaintStartsTarget(from, to, "dup").

DataOverlap(train, test) :- // split with slicing will be recognized as overlaps
    (FlowFromExtended(train, test, "data");
    FlowFromExtended(test, train, "data")).

DataOverlap(train, test) :-
    DuplicateEdge(des, _),
    FlowFromExtended(train, des, "data"),
    FlowFromExtended(test, des, "data").

DataOverlap(train, test) :-
    DuplicateEdge(des, src),
    FlowFromExtended(train, des, "data"),
    (FlowFromExtended(test, src, "data");
    FlowFromExtended(test, src_equiv, "data"), 
    FlowFromExtended(src, src_equiv, "equiv")).

DataOverlap(train, test) :-
    DuplicateEdge(des, src),
    FlowFromExtended(test, des, "data"),
    (FlowFromExtended(train, src, "data");
    FlowFromExtended(train, src_equiv, "data"), 
    FlowFromExtended(src, src_equiv, "equiv")).

OverlapLeak(testModel, trainModel, invo, meth) :-
    TrainTestPair(trainModel, train, testModel, test),
    TrainingDataWithModel(trainModel, train, invo, meth),
    TestDataWithModel(testModel, test, _, _),
    DataOverlap(train, test).

OverlapLeak(testModel, valModel, invo, meth) :-
    ValDataWithModel(valModel, val, invo, meth),
    TestDataWithModel(testModel, test, _, _),
    DataOverlap(val, test),
    DataOverlap(testModel, valModel).

// No Test detection
.decl NoTestData(trainModel:Var, invo:Invocation, meth:Method)

NoTestData(trainModel, invo, meth) :-
    TrainingDataWithModel(trainModel, train, invo, meth),
    !TrainTestPair(trainModel, train, _, _).

.decl MultiUseTestLeak(test:Var, invo:Invocation, meth:Method)
MultiUseTestLeak(test, invo, meth) :-
    TestDataWithModel(testModel, test, invo, meth),
    ScoredDataWithModel(testModel, test, invo, meth),
    TestDataWithModel(testModel2, test2, invo2, meth2),
    ScoredDataWithModel(testModel2, test2, invo2, meth2),
    invo != invo2,
    DataOverlap(test, test2).

// [TODO] separate validation/test, detect test multi-use

.output TrainTestPair
.output ValDataWithModel
.output ScoredDataWithModel
.output FlowFromEdge
.output FlowFrom
.output FlowFromExtended
.output TaintStartsTarget
.output TaintedVar
.output VarPointsTo
.output DataOverlap
.output PreProcessingLeak
.output OverlapLeak
.output NoTestData
.output MultiUseTestLeak