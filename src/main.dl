.type Var <: symbol
.type Type <: symbol
.type Field <: symbol
.type Index <: Var
.type Invocation <: symbol
.type Method <: symbol
.type Value <: symbol

#define ValueIdMacro(id, type) \
    cat(cat(cat(id, "::: "), type), "::: ")

// -- inputs --
// inner-procedural facts
.decl AssignVar(to:Var, from:Var)
.decl AssignStrConstant(to:Var, constant:symbol)
.decl AssignBoolConstant(to:Var, constant:symbol)
.decl AssignIntConstant(to:Var, constant:symbol)
.decl AssignFloatConstant(to:Var, constant:symbol)
.decl AssignBinOp(to:Var, left:Var, op:symbol, right:Var)
.decl LoadField(to:Var, base:Var, f:Field)
.decl StoreField(base:Var, f:Field, from:Var)
.decl LoadIndex(to:Var, base:Var, i:Index)
.decl StoreIndex(base:Var, i:Index, from:Var)
.decl LoadSlice(to:Var, base:Var, st:Var, ed:Var, step:Var)
.decl StoreSlice(to:Var, st:Var, ed:Var, step:Var, base:Var)

// inter-procedural facts
// .decl Invoke(invo:Invocation)
.decl ActualParam(index:number, invo:Invocation, var:Var)
.decl FormalParam(index:number, meth:Method, var:Var)
.decl ActualKeyParam(keyword:Var, invo:Invocation, var:Var)
// .decl FormalKeyParam(keyword:Var, meth:Method)
.decl ActualReturn(index:number, invo:Invocation, var:Var)
.decl FormalReturn(index:number, meth:Method, var:Var)
.decl CallGraphEdge(invo:Invocation, meth:Method)
// .decl MethodUpdate(meth:Method, index:number)
.decl VarType(var:Var, type:Type)
.decl Alloc(var:Var, value:Value)
.decl LocalMethod(meth:Method)
.decl LocalClass(cls:Type)
.decl InvokeInLoop(invo:Invocation)

.input AssignVar
.input AssignStrConstant
.input AssignBoolConstant
.input AssignIntConstant
.input AssignFloatConstant
.input AssignBinOp
.input LoadField
.input StoreField
.input LoadIndex
.input StoreIndex
.input LoadSlice
.input StoreSlice

.input ActualParam
.input FormalParam
.input ActualKeyParam
.input ActualReturn
.input FormalReturn
.input CallGraphEdge
.input VarType
.input Alloc
.input LocalMethod
.input LocalClass
.input InvokeInLoop


// .decl ParamToParamTaintTransferMethod(to:number, from:number, method:Method)
// .decl ParamToRetTaintTransferMethod(to:number, from:number, method:Method)
// .decl ParamKeyToRetTaintTransferMethod(to:number, from:Var, method:Method)


// .decl TaintSourceRetMethod(method:Method, index:number, taintType:symbol)
// .decl TaintSourceSetRetMethod(method:Method, to:number, from:number, taintType:symbol)
// .decl SinkMethod(method:Method, index:number, label:symbol)
// .decl ParamToParamSetTaintTransferMethod(to:number, from:number, method:Method)
// .decl ParamToRetSetTaintTransferMethod(to:number, from:number, method:Method)

// // heap flow analysis facts
// .decl ParamToRetSubsetMethod(to:number, from:number, method:Method)
// .decl ParamToRetEquivMethod(to:number, from:number, method:Method)

// Constant Propagation
.decl ConstantValue(var:Var, constant:symbol)
.decl VarEquals(var1:Var, var2:Var)

ConstantValue(var, constant) :-
    AssignBoolConstant(var, constant);
    AssignStrConstant(var, constant);
    AssignIntConstant(var, constant);
    AssignFloatConstant(var, constant).

ConstantValue(to, constant) :-
    VarPointsTo(from, value),
    VarPointsTo(to, value),
    ConstantValue(from, constant).

// Common Expression Detection
VarEquals(var1, var2) :-
    ConstantValue(var1, constant),
    ConstantValue(var2, constant).

VarEquals(var, var) :-
    VarPointsTo(var, _).

VarEquals(var1, var2) :-
    (LoadField(var1, base1, fld), LoadField(var2, base2, fld);
    LoadIndex(var1, base1, i1), LoadIndex(var2, base2, i2), (i1 = i2; VarEquals(i1, i2))),
    VarEquals(base1, base2).

VarEquals(var1, var2) :-
    CallGraphEdge(invo1, meth), ActualParam(1, invo1, param1), ActualReturn(0, invo1, var1),
    CallGraphEdge(invo2, meth), ActualParam(1, invo2, param2), ActualReturn(0, invo2, var2),
    meth = "len",
    VarEquals(param1, param2).


// data flow analysis input relations
.decl ParamToParamFlow(to:number, from:number, method:Method) 
.decl ParamToRetFlowFilterMethod(to:number, from:number, method:Method)

.decl ParamToRetEquivFlow(to:number, from:number, method:Method)
.decl ParamToRetCondEquivFlow(to:number, from:number, cond_id:number,method:Method)
.decl ParamContentToRetCondEquivFlow(to:number, from:number, cond_id:number,method:Method)
.decl FlowCondition(cond_id:number, keyword:Var, constant:symbol)


ParamToParamFlow(0, 1, "pandas.Series.fillna").
ParamToRetFlowFilterMethod(0, 0, meth) :-
    CallGraphEdge(_, meth),
    match(".*[.](fit|fit_transform|transform)", meth).

// ParamToRetEquivFlow(0, 0, "pandas.Series.fillna").
// ParamToRetEquivFlow(0, 1, "pandas.DataFrame").
// ParamToRetEquivFlow(0, 1, "pandas.concat").
// ParamToRetEquivFlow(0, 1, "pandas.get_dummies").

// **Conditional**
// ParamToRetEquivFlow(0, 0, "pandas.Series.drop").
// ParamToRetEquivFlow(0, 0, "pandas.DataFrame.drop").
ParamToRetEquivFlow(0, 0, "ndarray.reshape").
ParamToRetEquivFlow(0, 1, "numpy.array").
ParamToRetEquivFlow(0, 1, "sklearn.preprocessing.scale").
ParamToRetEquivFlow(0, 0, meth) :-
    CallGraphEdge(_, meth),
    match(".*[.](astype)", meth).

ParamToRetEquivFlow(0, 0, meth) :-
    CallGraphEdge(_, meth),
    match(".*[.](toarray)", meth).

ParamToRetEquivFlow(0, 1, meth) :-
    CallGraphEdge(_, meth),
    match(".*[.](transform|fit_transform)", meth).

ParamToRetEquivFlow(0, 1, meth) :-
    CallGraphEdge(_, meth),
    match("pandas[.](Series|DataFrame|get_dummies)", meth).

ParamToRetEquivFlow(0, 0, meth) :-
    CallGraphEdge(_, meth),
    match("pandas[.](Series|DataFrame)[.](copy|fillna|replace|map|apply|applymap)", meth).

ParamToRetCondEquivFlow(0, 0, 173, meth) :-
    CallGraphEdge(_, meth),
    match("pandas[.](Series|DataFrame)[.](drop)", meth).

// list member equiv
ParamContentToRetCondEquivFlow(0, 1, 173, meth) :-
    CallGraphEdge(_, meth),
    match("pandas[.](concat)", meth).

FlowCondition(173, "axis", "1").


// taint analysis input relations
.decl ParamToRetTaintSourceMethod(to:number, from:number, method:Method, taintType:symbol)
.decl ParamToParamTaintSourceMethod(to:number, from:number, method:Method, taintType:symbol)
.decl RetTaintSourceMethod(retIndex:number, method:Method, taintType:symbol)
.decl ParamToRetCondTaintSourceMethod(to:number, from:number, cond_id:number, method:Method, taintType:symbol)
.decl ParamToParamCondTaintSourceMethod(to:number, from:number, cond_id:number, method:Method, taintType:symbol)
.decl TaintCondition(cond_id:number, src_idx:number, taintType:symbol)


ParamToRetTaintSourceMethod(0, 1, meth, "rowset") :-
    CallGraphEdge(_, meth),
    match("numpy[.](nan)?(average|median|mean|std|var)", meth).
// ParamToRetTaintSourceMethod(0, 0, "Unknown.mean", "rowset").
ParamToRetTaintSourceMethod(0, 1, "pandas.cut", "rowset").
ParamToRetTaintSourceMethod(0, 1, "pandas.qcut", "rowset").
ParamToRetTaintSourceMethod(0, 0, meth, "rowset") :-
    CallGraphEdge(_, meth),
    match(".*(Unknown|Series|DataFrame|FrameOrSeries)[.](groupby|corr|cov|mode|mean|median|std|sum|describe)", meth). // some of them actually depends on the axis
ParamToRetTaintSourceMethod(0, 0, ".*[.]DataFrame.groupby", "rowset").
ParamToRetTaintSourceMethod(0, 1, "sklearn.preprocessing.scale", "rowset"). 
// sklearn.preprocessing.normalize when axis = 1

// pre-processing leaks 
ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset") :-
    CallGraphEdge(_, meth),
    match("(KBinsDiscretizer|PowerTransformer|QuantileTransformer|MaxAbsScaler|StandardScaler|MinMaxScaler|RobustScaler)[.]fit_transform", meth). 

ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset")  :-
    CallGraphEdge(_, meth),
    match("(KBinsDiscretizer|PowerTransformer|QuantileTransformer|MaxAbsScaler|StandardScaler|MinMaxScaler|RobustScaler)[.]fit", meth).

// imputer leaks (depends on the strategy)
ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset") :-
    CallGraphEdge(_, meth),
    match("(Imputer|SimpleImputer|IterativeImputer|KNNImputer)[.]fit_transform", meth). 

ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset")  :-
    CallGraphEdge(_, meth),
    match("(Imputer|SimpleImputer|IterativeImputer|KNNImputer)[.]fit", meth).

// feature selection leaks
ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset") :-
    CallGraphEdge(_, meth),
    match("(GenericUnivariateSelect|SelectPercentile|SelectKBest|SelectFpr|SelectFdr|SelectFromModel|SelectFwe|SequentialFeatureSelector|RFE|RFECV|VarianceThreshold)[.]fit_transform", meth). 

ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset")  :-
    CallGraphEdge(_, meth),
    match("(GenericUnivariateSelect|SelectPercentile|SelectKBest|SelectFpr|SelectFdr|SelectFromModel|SelectFwe|SequentialFeatureSelector|RFE|RFECV|VarianceThreshold)[.]fit", meth). 

// other leaks
ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset") :-
    CallGraphEdge(_, meth),
    match("(CountVectorizer|HashingVectorizer|TfidfTransformer|TfidfVectorizer|PCA)[.]fit_transform", meth). 

ParamToParamTaintSourceMethod(0, 1, meth, "rowset"),
ParamToRetTaintSourceMethod(0, 1, meth, "rowset")  :-
    CallGraphEdge(_, meth),
    match("(CountVectorizer|HashingVectorizer|TfidfTransformer|TfidfVectorizer|PCA)[.]fit", meth).

// pipeline leaks
RetTaintSourceMethod(0, "sklearn.preprocessing.Imputer", "pipeline"). // not always a problem, be conservative
RetTaintSourceMethod(0, "sklearn.preprocessing.MinMaxScaler", "pipeline"). 

ParamToRetCondTaintSourceMethod(0, 1, 4027, "DataFrameMapper.fit_transform", "rowset"). 
ParamToRetCondTaintSourceMethod(0, 1, 4027, "Pipeline.fit_transform",  "rowset").
TaintCondition(4027, 0, "pipeline").

ParamToRetTaintSourceMethod(0, 1, "ImageDataGenerator.flow", "dup"). 

// oversampling leak
ParamToRetTaintSourceMethod(0, 1, meth, "dup")  :-
    CallGraphEdge(_, meth),
    match("(RandomOverSampler|SMOTE|SMOTENC|SMOTEN|ADASYN|BorderlineSMOTE|KMeansSMOTE|SVMSMOTE)[.]fit_resample", meth).

// train/test locations
.decl TrainingData(method:Method, model_idx:number, data_index:number)
.decl TrainingDataByKey(method:Method, model_idx:number, datakw:Var)
.decl TestData(method:Method, model_idx:number, data_index:number)
.decl TestDataByKey(method:Method, model_idx:number, datakw:Var)
.decl ValData(method:Method, model_idx:number, data_index:number)
.decl ValDataByKey(method:Method, model_idx:number, datakw:Var)
.decl ScoredData(method:Method, model_idx:number, data_index:number)
.decl ScoredResult(method:Method, result_index:number)
.decl FilteredTrainingMethod(method:Method)

TrainingData(meth, 0, 1) :-
    CallGraphEdge(_, meth),
    match(".*[.](fit|fit_generator)", meth).

TrainingDataByKey(meth, 0, "generator") :-
    CallGraphEdge(_, meth),
    match(".*[.](fit_generator)", meth).

TestData(meth, 0, 1) :-
    CallGraphEdge(_, meth),
    match(".*[.](predict|score|evaluate|predict_proba)", meth).

TestDataByKey(meth, 0, "x") :-
    CallGraphEdge(_, meth),
    match(".*[.](predict_proba)", meth).

ValData(meth, 0, 1) :-
    CallGraphEdge(_, meth),
    match(".*(GridSearchCV|HalvingGridSearchCV|ParameterGrid|ParameterSampler|RandomizedSearchCV|HalvingRandomSearchCV)[.]fit", meth).

ValDataByKey(meth, 0, "validation_data") :-
    CallGraphEdge(_, meth),
    match(".*[.](fit|fit_generator)", meth).

ScoredData(meth, 0, 1) :-
    CallGraphEdge(_, meth),
    match(".*[.](score|evaluate)", meth).


ScoredResult(meth, 2) :-
    CallGraphEdge(_, meth),
    match(".*(accuracy_score|balanced_accuracy_score|top_k_accuracy_score|average_precision_score|brier_score_loss|f1_score|f1_score|f1_score|f1_score|f1_score|log_loss|precision_score|recall_score|jaccard_score|roc_auc_score|roc_auc_score|roc_auc_score|roc_auc_score|roc_auc_score|adjusted_mutual_info_score|adjusted_rand_score|completeness_score|fowlkes_mallows_score|homogeneity_score|mutual_info_score|normalized_mutual_info_score|rand_score|v_measure_score|explained_variance_score|max_error|mean_absolute_error|mean_squared_error|mean_squared_error|mean_squared_log_error|median_absolute_error|r2_score|mean_poisson_deviance|mean_gamma_deviance|mean_absolute_percentage_errors)", meth).

FilteredTrainingMethod(meth) :-
    CallGraphEdge(_, meth),
    (match("(GenericUnivariateSelect|SelectPercentile|SelectKBest|SelectFpr|SelectFdr|SelectFromModel|SelectFwe|SequentialFeatureSelector|RFE|RFECV|VarianceThreshold)[.]fit", meth);
    match("(CountVectorizer|HashingVectorizer|TfidfTransformer|TfidfVectorizer|PCA)[.]fit", meth);
    match("(Imputer|SimpleImputer|IterativeImputer|KNNImputer)[.]fit", meth);
    match("(KBinsDiscretizer|PowerTransformer|QuantileTransformer|MaxAbsScaler|StandardScaler|MinMaxScaler|RobustScaler)[.]fit", meth)).
 
// TrainingData("LogisticRegression.fit", 0, 1).
// TrainingData("GaussianNB.fit", 0, 1).
// TrainingData("Unknown.fit", 0, 1).
// TrainingData("Model.fit", 0, 1).
// TrainingData("Sequential.fit", 0, 1).

// TestData("LogisticRegression.predict", 0, 1).
// TestData("GaussianNB.predict", 0, 1).
// TestData("Unknown.predict_proba", 0, 1).
// TestData("Unknown.score", 0, 1).
// TestData("Model.evaluate", 0, 1).
// TestData("Sequential.evaluate", 0, 1).

// ParamToRetTaintTransferMethod(0, 1, "pandas.Series.fillna").
// ParamToParamTaintTransferMethod(0, 1, "pandas.Series.fillna").
// ParamToRetTaintTransferMethod(0, 0, "PCA.transform").
// ParamToRetTaintTransferMethod(0, 0, "SelectPercentile.transform").
// ParamToRetTaintTransferMethod(0, 1, "DataFrameMapper").
// ParamToRetTaintTransferMethod(0, 1, "Pipeline").
// ParamKeyToRetTaintTransferMethod(0, "transformer_list", "FeatureUnion").
// ParamToRetTaintTransferMethod(0, 1, "RandomizedSearchCV").

// ParamToRetSubsetMethod(0, 1, meth),
// ParamToRetSubsetMethod(1, 1, meth),
// ParamToRetSubsetMethod(2, 2, meth),
// ParamToRetSubsetMethod(3, 2, meth) :-
//     CallGraphEdge(_, meth),
//     match(".*train_test_split", meth).



// ---- pointer analysis ----

.decl VarPointsTo(var:Var, value:Value)
.decl IndexContentPointsTo(baseValue:Value, index:Index, value:Value)
.decl FieldPointsTo(base:Value, field:Field, value:Value)
.decl InterProcAssign(to:Var, from:Var)
.decl SliceIndex(st:Var, ed:Var, step:Var, index:Index)

SliceIndex(st, ed, step, index) :-
    LoadSlice(_, _, st, ed, step),
    index = ValueIdMacro(ValueIdMacro(st, ed), step).

SliceIndex(st, ed, step, index) :-
    StoreSlice(_, st, ed, step, _),
    index = ValueIdMacro(ValueIdMacro(st, ed), step).

// .decl TaintSource(taintValue:Value, srcValue:Value, taintType:symbol)
// .decl TaintFrom(to:Var, from:Var)

// .decl IsHeapObject(value:Value)
// .decl IsTaintObject(value:Value)

VarPointsTo(var, value) :- Alloc(var, value).
VarPointsTo(to, value) :- 
    AssignVar(to, from),
    VarPointsTo(from, value).
VarPointsTo(to, value) :- 
    LoadIndex(to, base, _),
    VarPointsTo(base, value). 
VarPointsTo(to, value) :- 
    LoadIndex(to, base, idx),
    VarPointsTo(base, baseValue),
    IndexContentPointsTo(baseValue, idx, value).    
IndexContentPointsTo(baseValue, idx, value) :- 
    StoreIndex(base, idx, from),
    VarPointsTo(base, baseValue),
    VarPointsTo(from, value).
VarPointsTo(to, value) :- 
    LoadField(to, base, _),
    VarPointsTo(base, value).
// VarPointsTo(base, value) :- 
//     StoreField(base, _, from),
//     VarPointsTo(from, value).
VarPointsTo(to, value) :- 
    LoadField(to, base, fld),
    VarPointsTo(base, baseValue),
    FieldPointsTo(baseValue, fld, value).
FieldPointsTo(baseValue, fld, value) :-
    StoreField(base, fld, from),
    VarPointsTo(base, baseValue),
    VarPointsTo(from, value).


// we always allocate new values for slice reference
// therefore we should propagate the new value back
IndexContentPointsTo(baseValue, idx, value) :- 
    LoadSlice(to, base, st, ed, step),
    SliceIndex(st, ed, step, idx),
    Alloc(to, value),
    VarPointsTo(base, baseValue).
VarPointsTo(to, value) :- 
    LoadSlice(to, base, st, ed, step),
    SliceIndex(st, ed, step, idx),
    VarPointsTo(base, baseValue),
    IndexContentPointsTo(baseValue, idx, value).  
IndexContentPointsTo(baseValue, idx, value) :- 
    StoreSlice(base, st, ed, step, from),
    SliceIndex(st, ed, step, idx),
    VarPointsTo(base, baseValue),
    VarPointsTo(from, value).

InterProcAssign(to, from) :-
    CallGraphEdge(invo, meth),
    meth != "__phi__",
    FormalParam(index, meth, to),
    ActualParam(index, invo, from).

InterProcAssign(to, from) :-
    CallGraphEdge(invo, meth),
    meth != "__phi__",
    FormalParam(_, meth, to),
    ActualKeyParam(to, invo, from).

InterProcAssign(to, from) :-
    CallGraphEdge(invo, meth),
    meth != "__phi__",
    FormalReturn(index, meth, from),
    ActualReturn(index, invo, to).

VarPointsTo(to, value) :- 
    InterProcAssign(to, from),
    VarPointsTo(from, value).
    // IsHeapObject(value).

// IsHeapObject(value) :-
//     Alloc(_, value).

// IsHeapSubset(subset, set) :-
//     ActualParam(fromIndex, invo, from),
//     VarPointsTo(from, set),
//     IsHeapObject(set),
//     ActualReturn(toIndex, invo, to),
//     VarPointsTo(to, subset),
//     IsHeapObject(subset),
//     CallGraphEdge(invo, meth),
//     ParamToRetSubsetMethod(toIndex, fromIndex, meth).

// IsHeapSubset(subset, set) :-
//     IsHeapSubset(subset, middleset),
//     IsHeapSubset(middleset, set).


// ---- data flow analysis ----
.decl FlowFrom(to:Var, from:Var, tag:symbol)
.decl FlowFromEdge(to:Var, from:Var, tag:symbol)
.decl FlowFromExtended(to:Var, from:Var, tag:symbol)
.decl NonDataTransferEdge(to:Var, from:Var)

FlowFromEdge(to, from, "normal") :-
    CallGraphEdge(invo, meth),
    (ActualParam(_, invo, from); ActualKeyParam(_, invo, from)),
    ActualReturn(_, invo, to),
    (!LocalMethod(meth); meth = "__phi__").

FlowFromEdge(to, from, "normal") :-
    CallGraphEdge(invo, meth),
    ParamToParamFlow(toIdx, fromIdx, meth),
    ActualParam(toIdx, invo, to),
    ActualParam(fromIdx, invo, from).

FlowFromEdge(to, from, "normal") :-
    InterProcAssign(to, from); AssignVar(to, from); LoadIndex(to, from, _); StoreIndex(to, _, from); 
    LoadField(to, from, _); StoreField(to, _, from); LoadSlice(to, from, _, _, _).

FlowFromEdge(to, left, "normal"),
FlowFromEdge(to, right, "normal") :-
    AssignBinOp(to, left, _, right).

FlowFromEdge(to, from, "equiv") :-
    InterProcAssign(to, from); AssignVar(to, from).

FlowFromEdge(to, from, "equiv") :-
    LoadField(to, from, f),
    (f = "loc"; f = "values"). // should also add type requirement [TODO]

FlowFromEdge(to, from, "equiv") :-
    LoadIndex(to, from, _). // should also add type requirement [TODO]

FlowFromEdge(to, from, "equiv") :-
    CallGraphEdge(invo, meth),
    ParamToRetEquivFlow(toIdx, fromIdx, meth),
    ActualParam(fromIdx, invo, from),
    ActualReturn(toIdx, invo, to).

FlowFromEdge(to, from, "equiv") :-
    CallGraphEdge(invo, meth),
    ParamToRetCondEquivFlow(toIdx, fromIdx, cond_id, meth),
    FlowCondition(cond_id, keyword, content),
    ActualKeyParam(keyword, invo, var),
    ConstantValue(var, content),
    ActualParam(fromIdx, invo, from),
    ActualReturn(toIdx, invo, to).

FlowFromEdge(to, from, "equiv") :-
    CallGraphEdge(invo, meth),
    ParamContentToRetCondEquivFlow(toIdx, fromIdx, cond_id, meth),
    FlowCondition(cond_id, keyword, content),
    ActualKeyParam(keyword, invo, var),
    ConstantValue(var, content),
    ActualParam(fromIdx, invo, fromList),
    VarPointsTo(fromList, fromListValue),
    VarPointsTo(from, fromValue),
    IndexContentPointsTo(fromListValue, _, fromValue),
    ActualReturn(toIdx, invo, to).

NonDataTransferEdge(to, from) :-
    ParamToRetFlowFilterMethod(to_idx, from_idx, meth),
    CallGraphEdge(invo, meth),
    ActualParam(from_idx, invo, from),
    ActualReturn(to_idx, invo, to).

FlowFromEdge(to, from, "data") :-
    !NonDataTransferEdge(to, from),
    FlowFromEdge(to, from, "normal").

FlowFrom(to, from, tag) :-
    FlowFromEdge(to, from, tag).

FlowFrom(to, from, tag) :-
    FlowFrom(to, mid, tag),
    FlowFrom(mid, from, tag).


FlowFromExtended(to, from, tag) :-
    FlowFrom(to, from, tag).

FlowFromExtended(to, from, "data"),
FlowFromExtended(to, from, "equiv"),
FlowFromExtended(to, from, "normal") :-
    VarPointsTo(to, value),
    VarPointsTo(from, value).


// FlowFromExtended(to, from, "data"),
// FlowFromExtended(to, from, "equiv"),
// FlowFromExtended(to, from, "normal") :-
//     VarPointsTo(to, baseValue),
//     IndexContentPointsTo(baseValue, _, value),
//     VarPointsTo(from, value).


// FlowFromExtended(to, from, "data"),
// FlowFromExtended(to, from, "equiv"),
// FlowFromExtended(to, from, "normal") :-
//     VarPointsTo(to, baseValue),
//     FieldPointsTo(baseValue, _, value),
//     VarPointsTo(from, value).

FlowFromExtended(to, from, tag) :-
    FlowFromExtended(to, mid, tag),
    FlowFromExtended(mid, from, tag).

// ---- derived training/validation/test data rules ----
.decl TrainingDataWithModel(model:Var, train:Var, invo:Invocation, meth:Method)
.decl ValOrTestDataWithModel(model:Var, test:Var, invo:Invocation, meth:Method)
.decl ScoredDataWithModel(model:Var, test:Var, invo:Invocation, meth:Method)
.decl TestDataWithModel(model:Var, test:Var, invo:Invocation, meth:Method)
.decl ValDataWithModel(model:Var, val:Var, invo:Invocation, meth:Method)
.decl TrainTestPair(trainModel:Var, train:Var, testModel:Var, test:Var)

// .decl ValTestPair(trainModel:Var, train:Var, testModel:Var, test:Var)

TrainingDataWithModel(model, train, invo, meth) :-
    (TrainingData(meth, model_idx, idx),
    ActualParam(idx, invo, train);
    TrainingDataByKey(meth, model_idx, keyword),
    ActualKeyParam(keyword, invo, train)),
    CallGraphEdge(invo, meth),
    !FilteredTrainingMethod(meth),
    ActualParam(model_idx, invo, model).

// could be both
ValOrTestDataWithModel(model, test, invo, meth) :-
    (TestData(meth, model_idx, idx),
    ActualParam(idx, invo, test);
    TestDataByKey(meth, model_idx, keyword),
    ActualKeyParam(keyword, invo, test)),
    CallGraphEdge(invo, meth),
    ActualParam(model_idx, invo, model).

ScoredDataWithModel(model, test, invo, meth) :-
    ValOrTestDataWithModel(model, test, invo, meth),
    ScoredData(meth, model_idx, idx),
    ActualParam(idx, invo, test),
    ActualParam(model_idx, invo, model).

ScoredDataWithModel(model, test, invo, meth) :-
    ValOrTestDataWithModel(model, test, invo, meth),
    ActualReturn(ret_idx, invo, ret),
    ret_idx = 0,
    FlowFromExtended(res, ret, _),
    ScoredResult(meth2, res_idx),
    CallGraphEdge(invo2, meth2),
    ActualParam(res_idx, invo2, res).

ValDataWithModel(model, val, invo, meth) :-
    (ValData(meth, model_idx, idx),
    ActualParam(idx, invo, val);
    ValDataByKey(meth, model_idx, keyword),
    ActualKeyParam(keyword, invo, val)),
    CallGraphEdge(invo, meth),
    ActualParam(model_idx, invo, model).

ValDataWithModel(model, val, invo, meth) :-
    ValDataByKey(meth, model_idx, keyword),
    keyword = "validation_data",
    ActualKeyParam(keyword, invo, tup),
    StoreIndex(tup, "0", val),
    CallGraphEdge(invo, meth),
    ActualParam(model_idx, invo, model).

ValDataWithModel(model, val, invo, meth) :-
    ValOrTestDataWithModel(model, val, invo, meth),
    InvokeInLoop(invo).

// exactly the same, or overlapping data?
ValDataWithModel(testModel, val, invo, meth),
ValDataWithModel(testModel2, val, invo2, meth2) :-
    ScoredDataWithModel(testModel, val, invo, meth),
    ScoredDataWithModel(testModel2, val, invo2, meth2),
    invo != invo2,
    !DataOverlap(testModel, testModel2).

ValDataWithModel(model, test, invo, meth) :-
    ValOrTestDataWithModel(model, test, invo, meth),
    ValDataWithModel(testModel, val, invo, meth),
    DataOverlap(model, testModel),
    DataOverlap(test, val).

TestDataWithModel(model, test, invo, meth) :-
    ValOrTestDataWithModel(model, test, invo, meth),
    !ValDataWithModel(model, test, invo, meth).
    // !ValDataWithModel(model, test, _, _). // and there should be no flow between test and val! [TODO]

// ValTestPair(valModel, val, testModel, test) :-
//     TestDataWithModel(testModel, test, _, _),
//     ValDataWithModel(valModel, val, _, _),
//     (val = test; FlowFrom(test, val, _); FlowFrom(val, test, _)),
//     (valModel = testModel; FlowFromExtended(testModel, valModel, _)).

TrainTestPair(trainModel, train, testModel, test) :-
    TestDataWithModel(testModel, test, _, _),
    TrainingDataWithModel(trainModel, train, _, _),
    !DataOverlap(train, test),
    DataOverlap(trainModel, testModel).
    // train != test, !FlowFrom(test, train, _),
    // (trainModel = testModel; FlowFromExtended(testModel, trainModel, _)). // how to handle model propagation? [TODO]

TrainValPair(trainModel, train, valModel, val) :-
    ValDataWithModel(valModel, val, _, _),
    TrainingDataWithModel(trainModel, train, _, _),
    !DataOverlap(train, val),
    DataOverlap(trainModel, valModel).
    // train != val, !FlowFrom(val, train, _),
    // (trainModel = valModel; FlowFromExtended(valModel, trainModel, _)). 

// ---- leak detection ----
.decl Leak(var:Var, invo:Invocation, meth:Method)
.decl PreProcessingLeak(var:Var, invo:Invocation, meth:Method)
.decl OverlapLeak(testModel:Var, trainModel:Var, invo:Invocation, meth:Method)


Leak(var, invo, meth) :-
    PreProcessingLeak(var, invo, meth);
    OverlapLeak(_, var, invo, meth).

// General edges/taints
.decl TaintStarts(var:Var, label:symbol)
.decl TaintStartsTarget(target:Var, src:Var, label:symbol)
.decl TaintedVar(var:Var)

TaintStarts(var, label) :-
    CallGraphEdge(invo, meth),
    RetTaintSourceMethod(idx, meth, label),
    ActualReturn(idx, invo, var).

TaintStarts(var, label),
TaintStartsTarget(target, var, label) :-
    CallGraphEdge(invo, meth),
    (ParamToParamTaintSourceMethod(toIdx, fromIdx, meth, label), ActualParam(toIdx, invo, target);
    ParamToRetTaintSourceMethod(toIdx, fromIdx, meth, label), ActualReturn(toIdx, invo, target);
    ParamToRetCondTaintSourceMethod(toIdx, fromIdx, cond_id, meth, label), TaintCondition(cond_id, srcIdx, srcTaintType),
    ActualParam(srcIdx, invo, src), FlowFrom(src, src_start, _), TaintStarts(src_start, srcTaintType), ActualReturn(toIdx, invo, target)),
    ActualParam(fromIdx, invo, var).

TaintedVar(var) :-  
    TaintStarts(var, _).

TaintedVar(to) :-  
    FlowFromExtended(to, from, _),
    TaintedVar(from).


// pre-processing leaks
.decl ReduceEdge(to:Var, from:Var)

ReduceEdge(to, from) :-
    TaintStartsTarget(to, from, "rowset").

PreProcessingLeak(src, invo, meth) :-
    TrainTestPair(trainModel, train, testModel, test),
    TrainingDataWithModel(trainModel, train, invo, meth),
    TestDataWithModel(testModel, test, _, _),
    ReduceEdge(reduced_from_src, src),
    FlowFromExtended(train, reduced_from_src, _),
    DataOverlap(test, src).
    // (FlowFromExtended(test, src, "data");
    // FlowFromExtended(test, src_equiv, "data"), FlowFromExtended(src, src_equiv, "equiv")).

PreProcessingLeak(src, invo, meth) :-
    TrainTestPair(trainModel, train, testModel, test),
    TrainingDataWithModel(trainModel, train, invo, meth),
    TestDataWithModel(testModel, test, _, _),
    ReduceEdge(reduced_from_src, src),
    FlowFromExtended(test, reduced_from_src, _),
    DataOverlap(test, src).

// Overlap detection
.decl DataOverlap(train:Var, test:Var)
.decl DuplicateEdge(to:Var, from:Var)

DuplicateEdge(to, from) :-
    TaintStartsTarget(to, from, "dup").

DataOverlap(train, test) :- // split with slicing will never be recognized as overlaps
    FlowFromExtended(test, src_equiv, "data"), 
    FlowFromExtended(train, src_equiv, "equiv").

DataOverlap(train, test) :- DataOverlap(test, train).

DataOverlap(train, test) :-
    DuplicateEdge(des, _),
    FlowFromExtended(train, des, "data"),
    FlowFromExtended(test, des, "data").

DataOverlap(train, test) :-
    DuplicateEdge(des, src),
    FlowFromExtended(train, des, "data"),
    DataOverlap(test, src).

DataOverlap(train, test) :-
    DuplicateEdge(des, src),
    FlowFromExtended(test, des, "data"),
    DataOverlap(train, src).

OverlapLeak(testModel, trainModel, invo, meth) :-
    TrainTestPair(trainModel, train, testModel, test),
    TrainingDataWithModel(trainModel, train, invo, meth),
    TestDataWithModel(testModel, test, _, _),
    DataOverlap(train, test).

OverlapLeak(testModel, valModel, invo, meth) :-
    ValDataWithModel(valModel, val, invo, meth),
    TestDataWithModel(testModel, test, _, _),
    DataOverlap(val, test),
    DataOverlap(testModel, valModel).

// No Test detection
.decl NoValAndTestData(trainModel:Var, invo:Invocation, meth:Method)
.decl NoTestData(trainModel:Var, invo:Invocation, meth:Method)

NoValAndTestData(trainModel, invo, meth) :-
    TrainingDataWithModel(trainModel, train, invo, meth),
    !TrainValPair(trainModel, train, _, _),
    !TrainTestPair(trainModel, train, _, _).

NoTestData(trainModel, invo, meth) :-
    TrainingDataWithModel(trainModel, train, invo, meth),
    TrainValPair(trainModel, train, _, _),
    !TrainTestPair(trainModel, train, _, _).

.decl MultiUseTestLeak(test:Var, invo:Invocation, meth:Method)
MultiUseTestLeak(test, invo, meth) :-
    TestDataWithModel(testModel, test, invo, meth),
    ScoredDataWithModel(testModel, test, invo, meth),
    TestDataWithModel(testModel2, test2, invo2, meth2),
    ScoredDataWithModel(testModel2, test2, invo2, meth2),
    invo != invo2,
    DataOverlap(test, test2).

// [TODO] separate validation/test, detect test multi-use

.output TrainTestPair
.output ValDataWithModel
.output ScoredDataWithModel
.output FlowFromEdge
.output FlowFrom
.output FlowFromExtended
.output TaintStartsTarget
.output TaintedVar
.output VarPointsTo
.output DataOverlap
.output PreProcessingLeak
.output OverlapLeak
.output NoTestData
.output NoValAndTestData
.output MultiUseTestLeak